if (typeof chrome !== "undefined" && chrome.runtime && chrome.runtime.id) {
  document.documentElement.classList.add("is-extension");
}

// Performance optimizations and utilities
/**
 * Debounce utility for reducing function call frequency
 * @param {Function} func - Function to debounce
 * @param {number} wait - Wait time in milliseconds
 * @returns {Function} Debounced function
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Throttle utility for limiting function execution rate
 * @param {Function} func - Function to throttle
 * @param {number} limit - Time limit in milliseconds
 * @returns {Function} Throttled function
 */
function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

/**
 * Memoization decorator for caching expensive computations
 * @param {Function} fn - Function to memoize
 * @param {Function} keyGenerator - Optional function to generate cache key
 * @returns {Function} Memoized function
 */
function memoize(fn, keyGenerator) {
  const cache = new Map();
  const MAX_CACHE_SIZE = 100;
  
  return function(...args) {
    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn.apply(this, args);
    
    // Limit cache size
    if (cache.size >= MAX_CACHE_SIZE) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    cache.set(key, result);
    return result;
  };
}

/**
 * DOM element cache for avoiding repeated queries
 */
const domCache = new Map();
const DOM_CACHE_TTL = 10000; // 10 seconds

function getCachedElement(id) {
  const cached = domCache.get(id);
  if (cached && Date.now() - cached.timestamp < DOM_CACHE_TTL) {
    return cached.element;
  }
  
  const element = document.getElementById(id);
  if (element) {
    domCache.set(id, { element, timestamp: Date.now() });
  }
  return element;
}

function clearDOMCache() {
  domCache.clear();
}

/**
 * Request Animation Frame based batching for DOM updates
 */
class DOMBatcher {
  constructor() {
    this.queue = [];
    this.scheduled = false;
  }
  
  add(fn) {
    this.queue.push(fn);
    if (!this.scheduled) {
      this.scheduled = true;
      requestAnimationFrame(() => this.flush());
    }
  }
  
  flush() {
    const queue = this.queue.slice();
    this.queue = [];
    this.scheduled = false;
    
    // Execute all queued DOM updates in a single frame
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
    }
  }
}

const domBatcher = new DOMBatcher();

/**
 * Optimized formatters with memoization
 */
const formatBalance = memoize((value, decimals = 18) => {
  if (!value) return "0";
  try {
    return ethers.formatUnits(value, decimals);
  } catch {
    return "0";
  }
}, (value, decimals) => `${value}_${decimals}`);

const formatCurrency = memoize((value, currency = 'USD') => {
  if (!value || isNaN(value)) return '$0.00';
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(value);
});

const formatAddress = memoize((address) => {
  if (!address) return '';
  return address.slice(0, 6) + '...' + address.slice(-4);
});

// Constants for magic numbers
const CONSTANTS = {
  PASSWORD_ITERATIONS: 600000,
  RPC_TIMEOUT: 5000,
  GAS_UPDATE_DELAY: 5000,
  ENS_RESOLVE_DELAY: 500,
  SWAP_SIMULATION_DELAY: 300,
  AUTO_REFRESH_INTERVAL: 15000,
  MIN_PASSWORD_LENGTH: 8,
  MAX_PASSWORD_LENGTH: 256,
  DEFAULT_GAS_LIMIT: 21000,
  SWAP_GAS_LIMIT: 250000,
  CACHE_TTL: 5 * 60 * 1000,
  DOM_CACHE_TTL: 10000,
  MAX_CACHE_SIZE: 100
};

// Secure password modal handler
let passwordModalCallback = null;
let passwordModalReject = null;

function initPasswordModal() {
  const modal = document.getElementById('passwordModal');
  const form = document.getElementById('passwordForm');
  const passwordInput = document.getElementById('passwordInput');
  const confirmPasswordInput = document.getElementById('confirmPasswordInput');
  const confirmGroup = document.getElementById('confirmPasswordGroup');
  const errorDiv = document.getElementById('passwordError');
  
  // Toggle password visibility
  document.getElementById('togglePassword')?.addEventListener('click', () => {
    const input = document.getElementById('passwordInput');
    const icon = document.getElementById('eyeIcon');
    if (input.type === 'password') {
      input.type = 'text';
      icon.setAttribute('d', 'M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24');
    } else {
      input.type = 'password';
      icon.setAttribute('d', 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z');
    }
  });
  
  document.getElementById('toggleConfirmPassword')?.addEventListener('click', () => {
    const input = document.getElementById('confirmPasswordInput');
    const icon = document.getElementById('confirmEyeIcon');
    if (input.type === 'password') {
      input.type = 'text';
      icon.setAttribute('d', 'M17.94 17.94A10.07 10.07 0 0112 20c-7 0-11-8-11-8a18.45 18.45 0 015.06-5.94M9.9 4.24A9.12 9.12 0 0112 4c7 0 11 8 11 8a18.5 18.5 0 01-2.16 3.19m-6.72-1.07a3 3 0 11-4.24-4.24');
    } else {
      input.type = 'password';
      icon.setAttribute('d', 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z');
    }
  });
  
  // Password strength checker
  passwordInput?.addEventListener('input', (e) => {
    if (confirmGroup.style.display !== 'none') {
      const strength = checkPasswordStrength(e.target.value);
      updatePasswordStrength(strength);
    }
  });
  
  // Form submission
  form?.addEventListener('submit', (e) => {
    e.preventDefault();
    const password = passwordInput.value;
    const confirmPassword = confirmPasswordInput.value;
    
    // Clear inputs immediately for security
    passwordInput.value = '';
    confirmPasswordInput.value = '';
    
    // Validation
    if (confirmGroup.style.display !== 'none' && password !== confirmPassword) {
      showPasswordError("Passwords don't match");
      return;
    }
    
    if (confirmGroup.style.display !== 'none' && password.length < 8) {
      showPasswordError("Password must be at least 8 characters");
      return;
    }
    
    // Close modal
    modal.style.display = 'none';
    errorDiv.style.display = 'none';
    
    // Callback with password
    if (passwordModalCallback) {
      passwordModalCallback(password);
      passwordModalCallback = null;
      passwordModalReject = null;
    }
  });
  
  // Cancel button
  document.getElementById('cancelPassword')?.addEventListener('click', () => {
    passwordInput.value = '';
    confirmPasswordInput.value = '';
    modal.style.display = 'none';
    errorDiv.style.display = 'none';
    
    if (passwordModalReject) {
      passwordModalReject(new Error('User cancelled'));
      passwordModalCallback = null;
      passwordModalReject = null;
    }
  });
  
  // Close on background click (mobile-friendly)
  modal?.addEventListener('click', (e) => {
    if (e.target === modal) {
      document.getElementById('cancelPassword').click();
    }
  });
}

function checkPasswordStrength(password) {
  let strength = 0;
  if (password.length >= 8) strength++;
  if (password.length >= 12) strength++;
  if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
  if (/[0-9]/.test(password)) strength++;
  if (/[^a-zA-Z0-9]/.test(password)) strength++;
  return strength;
}

function updatePasswordStrength(strength) {
  const bar = document.getElementById('strengthBar');
  const text = document.getElementById('strengthText');
  const div = document.getElementById('passwordStrength');
  
  div.style.display = 'block';
  
  const colors = ['#ff4444', '#ff8844', '#ffaa44', '#88cc44', '#44cc44'];
  const texts = ['Very Weak', 'Weak', 'Fair', 'Good', 'Strong'];
  
  bar.style.width = `${(strength / 5) * 100}%`;
  bar.style.background = colors[Math.min(strength - 1, 4)] || colors[0];
  text.textContent = texts[Math.min(strength - 1, 4)] || texts[0];
}

function showPasswordError(message) {
  const errorDiv = document.getElementById('passwordError');
  errorDiv.textContent = message;
  errorDiv.style.display = 'block';
  setManagedTimeout(() => {
    errorDiv.style.display = 'none';
  }, 3000);
}

// Input sanitization helper
function sanitizeInput(input) {
  if (typeof input !== 'string') return '';
  // Remove any HTML/script tags
  return input.replace(/<[^>]*>/g, '')
    .replace(/javascript:/gi, '')
    .replace(/on\w+=/gi, '')
    .trim();
}

// HTML escape for display
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

/**
 * Comprehensive Input Validation System
 */
class InputValidator {
  /**
   * Validate Ethereum address
   * @param {string} address - Address to validate
   * @returns {object} { valid: boolean, error?: string }
   */
  static validateAddress(address) {
    if (!address) {
      return { valid: false, error: 'Address is required' };
    }
    
    // Remove whitespace
    address = address.trim();
    
    // Check if it's an ENS name
    if (address.endsWith('.eth')) {
      return InputValidator.validateENS(address);
    }
    
    // Check basic format
    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {
      return { valid: false, error: 'Invalid address format' };
    }
    
    // Use ethers.js validation
    try {
      if (!ethers.isAddress(address)) {
        return { valid: false, error: 'Invalid Ethereum address' };
      }
    } catch (e) {
      return { valid: false, error: 'Invalid address' };
    }
    
    // Check for zero address
    if (address.toLowerCase() === '0x0000000000000000000000000000000000000000') {
      return { valid: false, error: 'Cannot send to zero address' };
    }
    
    return { valid: true, address: ethers.getAddress(address) }; // Return checksummed address
  }
  
  /**
   * Validate ENS name
   * @param {string} name - ENS name to validate
   * @returns {object} { valid: boolean, error?: string }
   */
  static validateENS(name) {
    if (!name) {
      return { valid: false, error: 'ENS name is required' };
    }
    
    name = name.trim().toLowerCase();
    
    // Check format
    if (!name.endsWith('.eth')) {
      return { valid: false, error: 'ENS names must end with .eth' };
    }
    
    // Check for valid characters (alphanumeric and hyphens)
    const label = name.slice(0, -4);
    if (!/^[a-z0-9-]+$/.test(label)) {
      return { valid: false, error: 'ENS names can only contain letters, numbers, and hyphens' };
    }
    
    // Check length (min 3 characters for the label)
    if (label.length < 3) {
      return { valid: false, error: 'ENS name must be at least 3 characters' };
    }
    
    // Check for consecutive hyphens or starting/ending with hyphen
    if (/--/.test(label) || label.startsWith('-') || label.endsWith('-')) {
      return { valid: false, error: 'Invalid ENS name format' };
    }
    
    return { valid: true, ens: name };
  }
  
  /**
   * Validate token amount
   * @param {string} amount - Amount to validate
   * @param {number} decimals - Token decimals
   * @param {string} balance - User's balance
   * @returns {object} { valid: boolean, error?: string, value?: bigint }
   */
  static validateAmount(amount, decimals = 18, balance = null) {
    if (!amount || amount === '') {
      return { valid: false, error: 'Amount is required' };
    }
    
    // Remove whitespace
    amount = amount.trim();
    
    // Check for valid number format
    if (!/^\d*\.?\d*$/.test(amount)) {
      return { valid: false, error: 'Invalid amount format' };
    }
    
    // Check for multiple decimal points
    if ((amount.match(/\./g) || []).length > 1) {
      return { valid: false, error: 'Invalid amount format' };
    }
    
    // Check decimal places
    const parts = amount.split('.');
    if (parts[1] && parts[1].length > decimals) {
      return { valid: false, error: `Maximum ${decimals} decimal places allowed` };
    }
    
    // Check for zero amount
    const numAmount = parseFloat(amount);
    if (numAmount <= 0) {
      return { valid: false, error: 'Amount must be greater than 0' };
    }
    
    // Check for very large amounts
    if (numAmount > 1e15) {
      return { valid: false, error: 'Amount too large' };
    }
    
    try {
      // Convert to wei/smallest unit
      const value = ethers.parseUnits(amount, decimals);
      
      // Check against balance if provided
      if (balance !== null) {
        const balanceWei = ethers.parseUnits(balance.toString(), decimals);
        if (value > balanceWei) {
          return { valid: false, error: 'Insufficient balance' };
        }
      }
      
      return { valid: true, value, formatted: amount };
    } catch (e) {
      return { valid: false, error: 'Invalid amount' };
    }
  }
  
  /**
   * Validate RPC URL
   * @param {string} url - RPC URL to validate
   * @returns {object} { valid: boolean, error?: string }
   */
  static validateRPCUrl(url) {
    if (!url) {
      return { valid: false, error: 'RPC URL is required' };
    }
    
    url = url.trim();
    
    // Check URL format
    try {
      const parsed = new URL(url);
      
      // Only allow HTTPS and WSS for security
      if (!['https:', 'wss:'].includes(parsed.protocol)) {
        return { valid: false, error: 'Only HTTPS and WSS protocols are allowed' };
      }
      
      // Block localhost/private IPs in production
      const hostname = parsed.hostname.toLowerCase();
      if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.') || hostname.startsWith('10.')) {
        return { valid: false, error: 'Local/private RPC endpoints not allowed' };
      }
      
      // Check for common RPC endpoints patterns
      const validPatterns = [
        /infura\.io/,
        /alchemy\.com/,
        /quicknode\.com/,
        /ankr\.com/,
        /llamarpc\.com/,
        /publicnode\.com/,
        /cloudflare-eth\.com/,
        /chainstack\.com/,
        /polygon-rpc\.com/,
        /arbitrum\.io/,
        /optimism\.io/
      ];
      
      const isKnownProvider = validPatterns.some(pattern => pattern.test(hostname));
      
      // Warning for unknown providers
      if (!isKnownProvider) {
        console.warn('Using unknown RPC provider:', hostname);
      }
      
      return { valid: true, url: parsed.href };
    } catch (e) {
      return { valid: false, error: 'Invalid URL format' };
    }
  }
  
  /**
   * Validate private key
   * @param {string} key - Private key to validate
   * @returns {object} { valid: boolean, error?: string }
   */
  static validatePrivateKey(key) {
    if (!key) {
      return { valid: false, error: 'Private key is required' };
    }
    
    // Remove whitespace and 0x prefix if present
    key = key.trim().replace(/^0x/i, '');
    
    // Check length (64 hex characters)
    if (key.length !== 64) {
      return { valid: false, error: 'Private key must be 64 characters (32 bytes)' };
    }
    
    // Check for valid hex characters
    if (!/^[a-fA-F0-9]{64}$/.test(key)) {
      return { valid: false, error: 'Private key must be hexadecimal' };
    }
    
    // Verify it can create a valid wallet
    try {
      const wallet = new ethers.Wallet('0x' + key);
      if (!wallet.address) {
        return { valid: false, error: 'Invalid private key' };
      }
      return { valid: true, key: '0x' + key };
    } catch (e) {
      return { valid: false, error: 'Invalid private key format' };
    }
  }
  
  /**
   * Validate token contract address
   * @param {string} address - Contract address
   * @param {object} provider - Ethers provider
   * @returns {Promise<object>} { valid: boolean, error?: string, isContract?: boolean }
   */
  static async validateTokenContract(address, provider) {
    // First validate as address
    const addressValidation = InputValidator.validateAddress(address);
    if (!addressValidation.valid) {
      return addressValidation;
    }
    
    try {
      // Check if address has code (is a contract)
      const code = await provider.getCode(address);
      if (code === '0x' || code === '0x0') {
        return { valid: false, error: 'Address is not a smart contract' };
      }
      
      return { valid: true, address: addressValidation.address, isContract: true };
    } catch (e) {
      return { valid: false, error: 'Failed to verify contract' };
    }
  }
  
  /**
   * Validate gas price
   * @param {string} gasPrice - Gas price in Gwei
   * @returns {object} { valid: boolean, error?: string, value?: bigint }
   */
  static validateGasPrice(gasPrice) {
    if (!gasPrice) {
      return { valid: false, error: 'Gas price is required' };
    }
    
    gasPrice = gasPrice.trim();
    
    // Check format
    if (!/^\d*\.?\d*$/.test(gasPrice)) {
      return { valid: false, error: 'Invalid gas price format' };
    }
    
    const numGasPrice = parseFloat(gasPrice);
    
    // Check reasonable bounds (0.1 to 1000 Gwei)
    if (numGasPrice < 0.1) {
      return { valid: false, error: 'Gas price too low (min 0.1 Gwei)' };
    }
    
    if (numGasPrice > 1000) {
      return { valid: false, error: 'Gas price too high (max 1000 Gwei)' };
    }
    
    try {
      const value = ethers.parseUnits(gasPrice, 'gwei');
      return { valid: true, value, gwei: numGasPrice };
    } catch (e) {
      return { valid: false, error: 'Invalid gas price' };
    }
  }
  
  /**
   * Validate slippage percentage
   * @param {string} slippage - Slippage percentage
   * @returns {object} { valid: boolean, error?: string, value?: number }
   */
  static validateSlippage(slippage) {
    if (!slippage) {
      return { valid: false, error: 'Slippage is required' };
    }
    
    slippage = slippage.trim();
    
    // Check format
    if (!/^\d*\.?\d*$/.test(slippage)) {
      return { valid: false, error: 'Invalid slippage format' };
    }
    
    const numSlippage = parseFloat(slippage);
    
    // Check bounds (0.01% to 50%)
    if (numSlippage < 0.01) {
      return { valid: false, error: 'Slippage too low (min 0.01%)' };
    }
    
    if (numSlippage > 50) {
      return { valid: false, error: 'Slippage too high (max 50%)' };
    }
    
    // Warning for high slippage
    if (numSlippage > 5) {
      console.warn('High slippage warning:', numSlippage + '%');
    }
    
    return { valid: true, value: numSlippage };
  }
  
  /**
   * Validate password strength
   * @param {string} password - Password to validate
   * @returns {object} { valid: boolean, error?: string, strength?: number }
   */
  static validatePassword(password) {
    if (!password) {
      return { valid: false, error: 'Password is required' };
    }
    
    // Check minimum length
    if (password.length < 8) {
      return { valid: false, error: 'Password must be at least 8 characters' };
    }
    
    // Check maximum length
    if (password.length > 256) {
      return { valid: false, error: 'Password too long (max 256 characters)' };
    }
    
    // Calculate strength
    let strength = 0;
    if (password.length >= 12) strength++;
    if (password.length >= 16) strength++;
    if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
    if (/[0-9]/.test(password)) strength++;
    if (/[^a-zA-Z0-9]/.test(password)) strength++;
    
    // Require minimum strength
    if (strength < 2) {
      return { valid: false, error: 'Password too weak. Use uppercase, lowercase, numbers, and symbols' };
    }
    
    return { valid: true, strength };
  }
}

// Secure password prompt replacement
function securePasswordPrompt(title, message, requireConfirm = false) {
  return new Promise((resolve, reject) => {
    const modal = document.getElementById('passwordModal');
    const titleEl = document.getElementById('passwordModalTitle');
    const messageEl = document.getElementById('passwordModalMessage');
    const confirmGroup = document.getElementById('confirmPasswordGroup');
    const strengthDiv = document.getElementById('passwordStrength');
    const passwordInput = document.getElementById('passwordInput');
    const confirmPasswordInput = document.getElementById('confirmPasswordInput');
    
    // Reset state
    passwordInput.value = '';
    confirmPasswordInput.value = '';
    document.getElementById('passwordError').style.display = 'none';
    
    // Set content
    titleEl.textContent = title || 'Enter Password';
    messageEl.textContent = message || '';
    
    // Show/hide confirm field
    confirmGroup.style.display = requireConfirm ? 'block' : 'none';
    strengthDiv.style.display = requireConfirm ? 'block' : 'none';
    
    // Show modal with flex display for centering
    modal.style.display = 'flex';
    
    // Focus input (important for mobile)
    setManagedTimeout(() => passwordInput.focus(), 100);
    
    // Set callbacks
    passwordModalCallback = resolve;
    passwordModalReject = reject;
  });
}

// Generate dynamic coin SVG
function generateCoinSVG(id) {
  const isDark = document.documentElement.getAttribute("data-theme") === "dark";
  const textColor = isDark ? "#ffffff" : "#000000";
  const goldColor = isDark ? "#FFD700" : "#DAA520";
  const shadowColor = isDark ? "#B8860B" : "#996515";

  return `<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
          <defs>
            <linearGradient id="coinGrad${id}" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:${goldColor};stop-opacity:1" />
              <stop offset="50%" style="stop-color:#FFA500;stop-opacity:1" />
              <stop offset="100%" style="stop-color:${shadowColor};stop-opacity:1" />
            </linearGradient>
          </defs>
          <circle cx="16" cy="16" r="14" fill="url(#coinGrad${id})" stroke="${shadowColor}" stroke-width="1"/>
          <circle cx="16" cy="16" r="11" fill="none" stroke="${shadowColor}" stroke-width="0.5" opacity="0.5"/>
          <text x="16" y="20" font-family="monospace" font-size="8" font-weight="bold" text-anchor="middle" fill="${textColor}">${id}</text>
        </svg>`;
}

// Token configuration with logos
const TOKEN_LOGOS = {
  ETH: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle cx="16" cy="16" r="16" fill="#627EEA"/><g fill="#FFF" fill-rule="nonzero"><path fill-opacity=".602" d="M16.498 4v8.87l7.497 3.35z"/><path d="M16.498 4L9 16.22l7.498-3.35z"/><path fill-opacity=".602" d="M16.498 21.968v6.027L24 17.616z"/><path d="M16.498 27.995v-6.028L9 17.616z"/><path fill-opacity=".2" d="M16.498 20.573l7.497-4.353-7.497-3.348z"/><path fill-opacity=".602" d="M9 16.22l7.498 4.353v-7.701z"/></g></g></svg>',
  USDC: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#3E73C4" cx="16" cy="16" r="16"/><g fill="#FFF"><path d="M20.022 18.124c0-2.124-1.28-2.852-3.84-3.156-1.828-.243-2.193-.728-2.193-1.578 0-.85.61-1.396 1.828-1.396 1.097 0 1.707.364 2.011 1.275a.458.458 0 00.427.303h.975a.416.416 0 00.427-.425v-.06a3.04 3.04 0 00-2.743-2.489V9.142c0-.243-.183-.425-.487-.486h-.915c-.243 0-.426.182-.487.486v1.396c-1.829.242-2.986 1.456-2.986 2.974 0 2.002 1.218 2.791 3.778 3.095 1.707.303 2.255.668 2.255 1.639 0 .97-.853 1.638-2.011 1.638-1.585 0-2.133-.667-2.316-1.578-.06-.242-.244-.364-.427-.364h-1.036a.416.416 0 00-.426.425v.06c.243 1.518 1.219 2.61 3.23 2.914v1.457c0 .242.183.425.487.485h.915c.243 0 .426-.182.487-.485V21.34c1.829-.303 3.047-1.578 3.047-3.217z"/><path d="M12.892 24.497c-4.754-1.7-7.192-6.98-5.424-11.653.914-2.55 2.925-4.491 5.424-5.402.244-.121.365-.303.365-.607v-.85c0-.242-.121-.424-.365-.485-.061 0-.183 0-.244.06a10.895 10.895 0 00-7.13 13.717c1.096 3.4 3.717 6.01 7.13 7.102.244.121.488 0 .548-.243.061-.06.061-.122.061-.243v-.85c0-.182-.182-.424-.365-.546zm6.46-18.936c-.244-.122-.488 0-.548.242-.061.061-.061.122-.061.243v.85c0 .243.182.485.365.607 4.754 1.7 7.192 6.98 5.424 11.653-.914 2.55-2.925 4.491-5.424 5.402-.244.121-.365.303-.365.607v.85c0 .242.121.424.365.485.061 0 .183 0 .244-.06a10.895 10.895 0 007.13-13.717c-1.096-3.46-3.778-6.07-7.13-7.162z"/></g></g></svg>',
  DAI: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd"><circle fill="#F4B731" fill-rule="nonzero" cx="16" cy="16" r="16"/><path d="M9.277 8h6.552c3.985 0 7.006 2.116 8.13 5.194H26v1.861h-1.611c.031.294.047.594.047.898v.046c0 .342-.02.68-.06 1.01H26v1.86h-2.08C22.767 21.905 19.77 24 15.83 24H9.277v-5.131H7v-1.86h2.277v-1.954H7v-1.86h2.277V8zm1.831 10.869v3.462h4.72c2.914 0 5.078-1.387 6.085-3.462H11.108zm11.366-1.86H11.108v-1.954h11.37c.041.307.063.622.063.944v.045c0 .329-.023.65-.067.964zM15.83 9.665c2.926 0 5.097 1.424 6.098 3.528h-10.82V9.666h4.72z" fill="#FFF"/></g></svg>',
  USDT: '<svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><g fill="none"><circle fill="#26A17B" cx="16" cy="16" r="16"/><path fill="#FFF" d="M17.922 17.383v-.002c-.11.008-.677.042-1.942.042-1.01 0-1.721-.03-1.971-.042v.003c-3.888-.171-6.79-.848-6.79-1.658 0-.809 2.902-1.486 6.79-1.66v2.644c.254.018.982.061 1.988.061 1.207 0 1.812-.05 1.925-.06v-2.643c3.88.173 6.775.85 6.775 1.658 0 .81-2.895 1.485-6.775 1.657m0-3.59v-2.366h5.414V7.819H8.595v3.608h5.414v2.365c-4.4.202-7.709 1.074-7.709 2.118 0 1.044 3.309 1.915 7.709 2.118v7.582h3.913v-7.584c4.393-.202 7.694-1.073 7.694-2.116 0-1.043-3.301-1.914-7.694-2.117"/></g></svg>',
  ENS: '<svg viewBox="0 0 202 231" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M98.3592 2.80337L34.8353 107.327C34.3371 108.147 33.1797 108.238 32.5617 107.505C26.9693 100.864 6.13478 72.615 31.9154 46.8673C55.4403 23.3726 85.4045 6.62129 96.5096 0.831705C97.7695 0.174847 99.0966 1.59007 98.3592 2.80337Z" fill="#0080BC"/><path d="M94.8459 230.385C96.1137 231.273 97.6758 229.759 96.8261 228.467C82.6374 206.886 35.4713 135.081 28.9559 124.302C22.5295 113.67 9.88976 96.001 8.83534 80.8842C8.7301 79.3751 6.64332 79.0687 6.11838 80.4879C5.27178 82.7767 4.37045 85.5085 3.53042 88.6292C-7.07427 128.023 8.32698 169.826 41.7753 193.238L94.8459 230.386V230.385Z" fill="#0080BC"/><path d="M103.571 228.526L167.095 124.003C167.593 123.183 168.751 123.092 169.369 123.825C174.961 130.465 195.796 158.715 170.015 184.463C146.49 207.957 116.526 224.709 105.421 230.498C104.161 231.155 102.834 229.74 103.571 228.526Z" fill="#0080BC"/><path d="M107.154 0.930762C105.886 0.0433954 104.324 1.5567 105.174 2.84902C119.363 24.4301 166.529 96.2354 173.044 107.014C179.471 117.646 192.11 135.315 193.165 150.432C193.27 151.941 195.357 152.247 195.882 150.828C196.728 148.539 197.63 145.808 198.47 142.687C209.074 103.293 193.673 61.4905 160.225 38.078L107.154 0.930762Z" fill="#0080BC"/></svg>',
  CULT: '<img src="https://assets.coingecko.com/coins/images/52583/standard/cult.jpg?1733712273" style="width: 100%; height: 100%; object-fit: contain;" />',
  ZAMM: '<img src="https://raw.githubusercontent.com/NaniDAO/coinchan/main/public/zammzamm.gif" style="width: 100%; height: 100%; object-fit: contain;" />',
};

// WETH address for ETH price
const WETH_ADDRESS = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

// zQuoter contract for finding best swap routes
const ZQUOTER_ADDRESS = "0xC802D186BdFC8F53F35dF9B424CAf13f5AC5aec7";

// ERC6909 addresses
const COINS_CONTRACT = "0x0000000000009710cd229bf635c4500029651ee8";
const ZAMM_ID = "1334160193485309697971829933264346612480800613613";

// ZAMM AMM Contracts for price fetching and swapping
const ZAMM_0_ADDRESS = "0x00000000000008882D72EfA6cCE4B6a40b24C860"; // Original ZAMM AMM for swapping ZAMM token
const ZAMM_1_ADDRESS = "0x000000000000040470635eb91b7ce4d132d616ed"; // New ZAMM AMM for all other ERC6909 ID swaps
const ZAMM_POOL_ID = "22979666169544372205220120853398704213623237650449182409187385558845249460832"; // ZAMM/ETH pool ID

// Price checking is now handled through zWallet contract which wraps CTC

const LS_WALLETS = "eth_wallets_v2";
const LS_LAST = "last_wallet_addr";

const KEY_VERSION = 1;
const DEFAULT_KDF = { kdf: "pbkdf2-sha256", iter: 600000 }; // OWASP 2024 recommended minimum

// Default tokens configuration
const DEFAULT_TOKENS = {
  ETH: { address: null, symbol: "ETH", name: "Ethereum", decimals: 18 },
  ZAMM: {
    address: COINS_CONTRACT,
    symbol: "ZAMM",
    name: "ZAMM",
    decimals: 18,
    isERC6909: true,
    id: ZAMM_ID,
  },
  USDT: {
    address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    symbol: "USDT",
    name: "Tether",
    decimals: 6,
  },
  DAI: {
    address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    symbol: "DAI",
    name: "Dai",
    decimals: 18,
  },
  USDC: {
    address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    symbol: "USDC",
    name: "USD Coin",
    decimals: 6,
  },
  ENS: {
    address: "0xC18360217D8F7Ab5e7c516566761Ea12Ce7F9D72",
    symbol: "ENS",
    name: "ENS",
    decimals: 18,
  },
  CULT: {
    address: "0x0000000000c5dc95539589fbD24BE07c6C14eCa4",
    symbol: "CULT",
    name: "Milady Cult Coin",
    decimals: 18,
  },
};

// USDC EIP-3009 constants for IOU functionality  
const USDC_EIP712_DOMAIN = Object.freeze({
  name: "USD Coin",
  version: "2",
  chainId: 1,
  verifyingContract: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
});

const EIP3009_TYPES = {
  TransferWithAuthorization: [
    { name: "from", type: "address" },
    { name: "to", type: "address" },
    { name: "value", type: "uint256" },
    { name: "validAfter", type: "uint256" },
    { name: "validBefore", type: "uint256" },
    { name: "nonce", type: "bytes32" }
  ]
};

// zWallet contract address and ABI
const ZWALLET_ADDRESS = "0x13e8874aB56f832C11e3Dfe748c0Ec22618c90B5";
const ZWALLET_ABI = [
  // Enhanced batch view with ENS and token type detection
  "function batchView(address user, address[] calldata tokens, uint256[] calldata ids) view returns (string ensName, address[] tokensOut, uint256[] idsOut, uint8[] kinds, uint256[] rawBalances, uint256[] balances, string[] names, string[] symbols, uint8[] decimals, uint256[] pricesETH, string[] pricesETHStr, uint256[] pricesUSDC, string[] pricesUSDCStr)",
  // Individual getters
  "function getBalanceOf(address owner, address token, uint256 id) view returns (uint256 raw, uint256 bal)",
  "function getMetadata(address token) view returns (string name, string symbol, uint8 decimals)",
  "function getOwnerOf(address token, uint256 id) view returns (address owner)",
  // Payload preparation
  "function getERC20Transfer(address to, uint256 amount) pure returns (bytes)",
  "function getERC20Approve(address spender, uint256 amount) pure returns (bytes)",
  "function getERC6909Transfer(address to, uint256 id, uint256 amount) pure returns (bytes)",
  "function getERC6909SetOperator(address spender, bool approved) pure returns (bytes)",
  "function getERC721TransferFrom(address from, address to, uint256 tokenId) pure returns (bytes)",
  // Token type detection
  "function isERC721(address token) view returns (bool)",
  "function isERC6909(address token) view returns (bool)",
  // Allowance and operator checks
  "function getAllowanceOf(address owner, address token, address spender) view returns (uint256 raw, uint256 allow)",
  "function getIsOperatorOf(address owner, address token, address spender) view returns (bool)",
  // Router approval helpers
  "function checkERC20RouterApproval(address owner, address token, uint256 amount, bool max) view returns (bytes payload)",
  "function checkERC6909RouterIsOperator(address owner, address token) view returns (bytes payload)",
  // Price checking (via CTC)
  "function checkPrice(address token) view returns (uint256 price, string priceStr)",
  "function checkPriceInETH(address token) view returns (uint256 price, string priceStr)",
  "function checkPriceInETHToUSDC(address token) view returns (uint256 price, string priceStr)",
  // ENS resolution
  "function whatIsTheAddressOf(string calldata name) view returns (address owner, address receiver, bytes32 node)",
  "function whatIsTheNameOf(address user) view returns (string ensName)",
];

const ERC20_ABI = [
  "function transfer(address, uint256) returns (bool)",
  "function approve(address, uint256) returns (bool)",
  "event Transfer(address indexed from, address indexed to, uint256 value)",
];

// ZAMM AMM ABI for reading pool reserves
const ZAMM_AMM_ABI = [
  "function pools(uint256 poolId) view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast, uint256 price0CumulativeLast, uint256 price1CumulativeLast, uint256 kLast, uint256 supply)",
];

// Global state
let wallet = null;
let provider = null;
let zWalletContract = null;
let zQuoterContract = null;
let selectedGasSpeed = "normal";
let currentBalances = {};
let tokenPrices = {};
let ethPrice = 0;
let selectedToken = "ETH";
let savedWallets = [];
let customTokens = {};
let currentRpc =
  localStorage.getItem("rpc_endpoint") || "https://eth.llamarpc.com";
let autoRefreshInterval = null;
let txHistory = [];
let ensResolveTimeout = null;
let gasUpdateTimeout = null;
let gasPrices = {
  slow: null,
  normal: null,
  fast: null,
  custom: null,
};
let TOKENS = { ...DEFAULT_TOKENS };
// IOU state for signing
let pendingIouMessage = null;
let pendingIouAmount = null;

// Event listener management for cleanup
const eventListeners = new Map();
const abortControllers = new Map();
const activeTimeouts = new Set();
const activeIntervals = new Set();
const cleanupCallbacks = new Set();

// Cache for RPC responses (5 minute TTL)
const rpcCache = new Map();
const CACHE_TTL = 5 * 60 * 1000; // 5 minutes

// Track all timers for cleanup
function setManagedTimeout(callback, delay) {
  const timeoutId = setTimeout(() => {
    activeTimeouts.delete(timeoutId);
    callback();
  }, delay);
  activeTimeouts.add(timeoutId);
  return timeoutId;
}

function clearManagedTimeout(timeoutId) {
  if (timeoutId && activeTimeouts.has(timeoutId)) {
    clearTimeout(timeoutId);
    activeTimeouts.delete(timeoutId);
  }
}

function setManagedInterval(callback, delay) {
  const intervalId = setInterval(callback, delay);
  activeIntervals.add(intervalId);
  return intervalId;
}

function clearManagedInterval(intervalId) {
  if (intervalId && activeIntervals.has(intervalId)) {
    clearInterval(intervalId);
    activeIntervals.delete(intervalId);
  }
}

// Register cleanup callbacks for components
function registerCleanup(callback) {
  cleanupCallbacks.add(callback);
  return () => cleanupCallbacks.delete(callback);
}

/**
 * Error Boundary System - Wraps functions with error handling
 */
class ErrorBoundary {
  static async wrapAsync(fn, context = 'Operation', fallback = null) {
    try {
      return await fn();
    } catch (error) {
      console.error(`[${context}] Error:`, error);
      
      // Show user-friendly error
      showError(error, context);
      
      // Return fallback value
      return fallback;
    }
  }
  
  static wrap(fn, context = 'Operation', fallback = null) {
    try {
      return fn();
    } catch (error) {
      console.error(`[${context}] Error:`, error);
      
      // Show user-friendly error
      const message = ErrorBoundary.getUserMessage(error, context);
      showToast(message, 5000, 'error');
      
      // Return fallback value
      return fallback;
    }
  }
  
  static getUserMessage(error, context) {
    // Common error patterns
    if (error.message?.includes('insufficient funds')) {
      return 'Insufficient balance for this transaction';
    }
    if (error.message?.includes('network')) {
      return 'Network error. Please check your connection';
    }
    if (error.message?.includes('rejected')) {
      return 'Transaction rejected';
    }
    if (error.message?.includes('timeout')) {
      return 'Request timed out. Please try again';
    }
    if (error.message?.includes('rate limit')) {
      return 'Too many requests. Please slow down';
    }
    
    // Default message
    return `${context} failed. Please try again`;
  }
  
  static wrapEventHandler(handler, context = 'Action') {
    return async (event) => {
      try {
        await handler(event);
      } catch (error) {
        console.error(`[${context}] Event handler error:`, error);
        showError(error, context);
      }
    };
  }
}

// Safe element selector with fallback
function safeGetElement(id, required = false) {
  const element = document.getElementById(id);
  if (!element && required) {
    console.error(`Required element not found: ${id}`);
    throw new Error(`Required element not found: ${id}`);
  }
  return element;
}

// Safe query selector with fallback
function safeQuerySelector(selector, parent = document, required = false) {
  const element = parent.querySelector(selector);
  if (!element && required) {
    console.error(`Required element not found: ${selector}`);
    throw new Error(`Required element not found: ${selector}`);
  }
  return element;
}

// Safe array access with bounds checking
function safeArrayAccess(array, index, fallback = null) {
  if (!Array.isArray(array) || index < 0 || index >= array.length) {
    return fallback;
  }
  return array[index];
}

// Safe object property access with null checking
function safePropertyAccess(obj, path, fallback = null) {
  if (!obj) return fallback;
  
  const keys = path.split('.');
  let current = obj;
  
  for (const key of keys) {
    if (current == null || typeof current !== 'object') {
      return fallback;
    }
    current = current[key];
  }
  
  return current ?? fallback;
}

// Safe division with zero checking
function safeDivide(numerator, denominator, fallback = 0) {
  if (!denominator || denominator === 0 || !Number.isFinite(denominator)) {
    console.warn('Division by zero or invalid denominator');
    return fallback;
  }
  const result = numerator / denominator;
  return Number.isFinite(result) ? result : fallback;
}

// Create managed AbortController for fetch requests
function createManagedAbortController(key) {
  // Cancel any existing controller with the same key
  if (abortControllers.has(key)) {
    const existing = abortControllers.get(key);
    existing.abort();
  }
  
  const controller = new AbortController();
  abortControllers.set(key, controller);
  
  // Return controller and cleanup function
  return {
    controller,
    signal: controller.signal,
    cleanup: () => {
      abortControllers.delete(key);
    }
  };
}

function getCachedOrFetch(key, fetchFn) {
  const cached = rpcCache.get(key);
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return Promise.resolve(cached.data);
  }
  
  return fetchFn().then(data => {
    rpcCache.set(key, { data, timestamp: Date.now() });
    // Limit cache size
    if (rpcCache.size > 100) {
      const firstKey = rpcCache.keys().next().value;
      rpcCache.delete(firstKey);
    }
    return data;
  });
}

function addManagedEventListener(element, event, handler, options = {}) {
  if (!element) return;
  
  const key = `${element.id || element.className}_${event}`;
  
  // Remove existing listener if present
  if (eventListeners.has(key)) {
    const { element: el, event: ev, handler: h } = eventListeners.get(key);
    el.removeEventListener(ev, h, options);
  }
  
  // Add new listener
  element.addEventListener(event, handler, options);
  eventListeners.set(key, { element, event, handler, options });
}

function cleanupEventListeners() {
  // Remove all managed event listeners - using for...of for better performance
  for (const { element, event, handler, options } of eventListeners.values()) {
    if (element && element.removeEventListener) {
      element.removeEventListener(event, handler, options);
    }
  }
  eventListeners.clear();
}

function cleanupTimers() {
  // Clear all managed timeouts - using for...of for better performance
  for (const timeoutId of activeTimeouts) {
    clearTimeout(timeoutId);
  }
  activeTimeouts.clear();
  
  // Clear all managed intervals - using for...of for better performance
  for (const intervalId of activeIntervals) {
    clearInterval(intervalId);
  }
  activeIntervals.clear();
  
  // Clear specific named timers
  if (ensResolveTimeout) {
    clearTimeout(ensResolveTimeout);
    ensResolveTimeout = null;
  }
  if (gasUpdateTimeout) {
    clearTimeout(gasUpdateTimeout);
    gasUpdateTimeout = null;
  }
  if (swapSimulationTimeout) {
    clearTimeout(swapSimulationTimeout);
    swapSimulationTimeout = null;
  }
  if (autoRefreshInterval) {
    clearInterval(autoRefreshInterval);
    autoRefreshInterval = null;
  }
}

function cleanupAbortControllers() {
  // Abort all pending requests
  abortControllers.forEach(controller => {
    try {
      controller.abort();
    } catch (e) {
      // Ignore errors from already aborted controllers
    }
  });
  abortControllers.clear();
}

function cleanupCache() {
  // Clear RPC cache
  rpcCache.clear();
}

function cleanupWalletState() {
  // Clear sensitive wallet data
  if (wallet) {
    wallet = null;
  }
  currentBalances = {};
  tokenPrices = {};
  txHistory = [];
  pendingIouMessage = null;
  pendingIouAmount = null;
}

/**
 * Master cleanup function - performs full resource cleanup
 * Used for major state changes but preserves wallet state
 */
function performFullCleanup() {
  // Run all cleanup callbacks
  cleanupCallbacks.forEach(callback => {
    try {
      callback();
    } catch (e) {
      console.error('Cleanup callback error:', e);
    }
  });
  
  cleanupEventListeners();
  cleanupTimers();
  cleanupAbortControllers();
  cleanupCache();
  
  // Don't clean wallet state on normal cleanup
  // Only on explicit logout or page unload
}

/**
 * Cleanup for wallet switching - clears timers and requests
 * Preserves event listeners and cache for performance
 */
function cleanupForWalletSwitch() {
  cleanupTimers();
  cleanupAbortControllers();
  // Keep event listeners and cache
}

/**
 * Complete cleanup on page unload - clears everything
 * Including sensitive wallet data for security
 */
function cleanupOnUnload() {
  performFullCleanup();
  cleanupWalletState();
  cleanupCallbacks.clear();
}

const enc = new TextEncoder(),
  dec = new TextDecoder();
async function deriveKey(pass, salt, meta) {
  const kdf = (meta && meta.kdf) || "pbkdf2-sha256";
  if (kdf === "pbkdf2-sha256") {
    let iter = Number((meta && meta.iter) || 600000);
    if (!Number.isFinite(iter) || iter < 10000 || iter > 5000000) iter = 600000;
    iter = Math.min(Math.max(10_000, Math.floor(iter)), 5_000_000); // clamp
    const km = await crypto.subtle.importKey(
      "raw",
      enc.encode(pass),
      "PBKDF2",
      false,
      ["deriveKey"]
    );
    return crypto.subtle.deriveKey(
      { name: "PBKDF2", salt, iterations: iter, hash: "SHA-256" },
      km,
      { name: "AES-GCM", length: 256 },
      false,
      ["encrypt", "decrypt"]
    );
  }
  throw new Error("Unsupported KDF: " + kdf);
}

const b64 = (u8) => btoa(String.fromCharCode(...u8));
const unb64 = (s) =>
  new Uint8Array(
    atob(s)
      .split("")
      .map((c) => c.charCodeAt(0))
  );

async function encryptPK(pkHex, pass, opts = {}) {
  const meta = { v: KEY_VERSION, ...DEFAULT_KDF, ...opts };
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(pass, salt, meta);
  const aad = meta.aad ? enc.encode(meta.aad) : undefined;
  const ct = new Uint8Array(
    await crypto.subtle.encrypt(
      { name: "AES-GCM", iv, additionalData: aad },
      key,
      enc.encode(pkHex)
    )
  );
  return { ...meta, ct: b64(ct), iv: b64(iv), salt: b64(salt) };
}

async function decryptPK(payload, pass, aadExpected) {
  const meta = {
    v: payload.v ?? 0,
    kdf: payload.kdf || "pbkdf2-sha256",
    iter: payload.iter || 600000,
    aad: payload.aad,
  };
  const key = await deriveKey(pass, unb64(payload.salt), meta);

  if (aadExpected && meta.aad && meta.aad !== aadExpected) {
    throw new Error("Keystore/address mismatch");
  }

  try {
    const aad = enc.encode(aadExpected || meta.aad || "");
    const pt = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv: unb64(payload.iv), additionalData: aad },
      key,
      unb64(payload.ct)
    );
    return dec.decode(pt);
  } catch (e) {
    // Legacy fallback: only try if no AAD was used originally
    if (!meta.aad && aadExpected) {
      const pt = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: unb64(payload.iv) }, // no AAD
        key,
        unb64(payload.ct)
      );
      return dec.decode(pt);
    }
    throw e;
  }
}

async function migrateKeystoreIfNeeded() {
  const list = JSON.parse(localStorage.getItem(LS_WALLETS) || "[]");
  let changed = false;
  for (const w of list) {
    const c = w.crypto;
    // Old shape had no v/kdf/iter – wrap it with defaults without touching ct/iv/salt
    if (c && c.ct && !("v" in c)) {
      w.crypto = { v: KEY_VERSION, ...DEFAULT_KDF, ...c };
      changed = true;
    }
  }
  if (changed) localStorage.setItem(LS_WALLETS, JSON.stringify(list));
}

// Initialize
async function init() {
  // Check if running as extension and handle CSP restrictions
  if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {
    // Keep service worker alive
    setManagedInterval(() => {
      chrome.runtime.sendMessage({ action: 'keepAlive' }, () => {
        if (chrome.runtime.lastError) {
          // Service worker was inactive, will restart automatically
        }
      });
    }, 20000); // Every 20 seconds
  }
  
  // Register cleanup on page unload
  window.addEventListener('beforeunload', cleanupOnUnload);
  window.addEventListener('unload', cleanupOnUnload);
  
  // Also cleanup on visibility change (mobile browsers)
  document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
      // Page is hidden, cleanup non-essential resources
      cleanupAbortControllers();
      cleanupCache();
    }
  });
  
  loadTheme();

  // Parallelize initialization tasks
  await Promise.all([
    migrateKeystoreIfNeeded(),
    initProvider(),
    loadCustomTokens()
  ]);
  
  // These depend on provider being ready
  loadWallets();

  // --- auto-unlock last wallet (with password prompt) ---
  try {
    const last = localStorage.getItem(LS_LAST);
    if (last) {
      const list = JSON.parse(localStorage.getItem(LS_WALLETS) || "[]");
      const entry = list.find(
        (w) => w.address.toLowerCase() === last.toLowerCase()
      );
      if (entry) {
        const label =
          entry.label ||
          entry.address.slice(0, 6) + "..." + entry.address.slice(-4);
        try {
          const pass = await securePasswordPrompt('Unlock Wallet', `Enter password to unlock ${label}:`);
          const pk = await decryptPK(
              entry.crypto,
              pass,
              entry.address.toLowerCase()
            );

            // Rewrap legacy keystores that were saved without AAD
            if (!entry.crypto.aad) {
              try {
                const newPayload = await encryptPK(pk, pass, {
                  aad: entry.address.toLowerCase(),
                });
                entry.crypto = newPayload;
                const listNow = JSON.parse(
                  localStorage.getItem(LS_WALLETS) || "[]"
                ).map((w) =>
                  w.address.toLowerCase() === entry.address.toLowerCase()
                    ? entry
                    : w
                );
                localStorage.setItem(LS_WALLETS, JSON.stringify(listNow));
              } catch (e) {
                
              }
            }

            wallet = new ethers.Wallet(pk, provider);
            await displayWallet();

            showToast("Wallet unlocked!");
          } catch (e) {
            
            // keep LS_LAST so user can try from selector
          }
      } else {
        // stale pointer, clean up
        localStorage.removeItem(LS_LAST);
      }
    }
  } catch (e) {
    
  }

  setupEventListeners();
  
  // Initialize keyboard shortcuts
  initKeyboardShortcuts();
  
  // Check if opened for dApp approval
  checkForDappRequest();
}

// Keyboard Shortcuts Handler
function initKeyboardShortcuts() {
  document.addEventListener('keydown', (e) => {
    // Skip if user is typing in an input
    if (e.target.matches('input, textarea, select')) return;
    
    // Tab navigation with number keys
    if (e.key >= '1' && e.key <= '5' && !e.ctrlKey && !e.metaKey) {
      const tabIndex = parseInt(e.key) - 1;
      const tabs = document.querySelectorAll('.tab');
      if (tabs[tabIndex]) {
        tabs[tabIndex].click();
      }
    }
    
    // Ctrl/Cmd + shortcuts
    if (e.ctrlKey || e.metaKey) {
      switch(e.key) {
        case 's': // Send
          e.preventDefault();
          document.querySelector('.tab[data-tab="send"]')?.click();
          break;
        case 'w': // Swap
          e.preventDefault();
          document.querySelector('.tab[data-tab="swap"]')?.click();
          break;
        case 'r': // Refresh balances
          e.preventDefault();
          if (wallet) {
            fetchAllBalances();
            showToast('Refreshing balances...');
          }
          break;
        case 'c': // Copy address
          e.preventDefault();
          if (wallet?.address) {
            copyToClipboard(wallet.address, 'address');
          }
          break;
      }
    }
  });
  
  // Add tooltip hints for shortcuts
  const tabs = document.querySelectorAll('.tab');
  tabs.forEach((tab, index) => {
    if (index < 5) {
      const text = tab.textContent;
      tab.title = `${text} (Press ${index + 1})`;
    }
  });
}

// Handle dApp requests when opened as popup
async function checkForDappRequest() {
  const params = new URLSearchParams(window.location.search);
  const requestId = params.get('request');
  const requestType = params.get('type');
  const origin = params.get('origin');
  
  if (!requestId || !requestType) return;
  
  // Show the dApp modal
  const modal = document.getElementById('dappApprovalModal');
  const originDiv = document.getElementById('dappOrigin');
  
  if (!modal || !originDiv) return;
  
  modal.classList.remove('hidden');
  // Safely set origin text to prevent XSS
  originDiv.textContent = '';
  const warningIcon = document.createTextNode('⚠️ Request from: ');
  const strongElem = document.createElement('strong');
  strongElem.textContent = decodeURIComponent(origin);
  originDiv.appendChild(warningIcon);
  originDiv.appendChild(strongElem);
  
  // Hide all request types first
  document.getElementById('connectionRequest')?.classList.add('hidden');
  document.getElementById('transactionRequest')?.classList.add('hidden');
  document.getElementById('signRequest')?.classList.add('hidden');
  
  // Get the request details from background script
  chrome.runtime.sendMessage({ 
    type: 'GET_REQUEST', 
    requestId: requestId 
  }, async (pendingRequest) => {
    if (!pendingRequest) {
      modal.classList.add('hidden');
      return;
    }
    
    switch (requestType) {
      case 'connect':
        handleConnectionRequest(requestId, pendingRequest);
        break;
      case 'transaction':
        await handleTransactionRequest(requestId, pendingRequest);
        break;
      case 'sign':
        handleSignRequest(requestId, pendingRequest);
        break;
    }
  });
}

function handleConnectionRequest(requestId, pendingRequest) {
  const connDiv = document.getElementById('connectionRequest');
  const accountDiv = document.getElementById('connectionAccount');
  const modalTitle = document.getElementById('dappModalTitle');
  
  if (!connDiv || !accountDiv || !modalTitle) return;
  
  modalTitle.textContent = 'Connect to DApp';
  connDiv.classList.remove('hidden');
  
  if (wallet) {
    accountDiv.textContent = wallet.address;
  } else {
    accountDiv.textContent = 'No wallet connected';
  }
  
  // Setup approve/reject handlers
  const approveBtn = document.getElementById('approveDapp');
  const rejectBtn = document.getElementById('rejectDapp');
  
  if (approveBtn) {
    approveBtn.onclick = async () => {
      if (!wallet) {
        showError('Please unlock your wallet first', 'Action');
        return;
      }
      
      // Store connected site
      chrome.storage.local.set({ 
        [`connected_${pendingRequest.origin}`]: true,
        'current_wallet': wallet.address 
      });
      
      // Send response
      chrome.runtime.sendMessage({
        type: 'USER_RESPONSE',
        requestId: requestId,
        response: { result: [wallet.address] }
      });
      
      window.close();
    };
  }
  
  if (rejectBtn) {
    rejectBtn.onclick = () => {
      chrome.runtime.sendMessage({
        type: 'USER_RESPONSE',
        requestId: requestId,
        response: { error: { code: 4001, message: 'User rejected connection' } }
      });
      
      window.close();
    };
  }
}

async function handleTransactionRequest(requestId, pendingRequest) {
  const txDiv = document.getElementById('transactionRequest');
  const modalTitle = document.getElementById('dappModalTitle');
  
  if (!txDiv || !modalTitle) return;
  
  modalTitle.textContent = 'Approve Transaction';
  txDiv.classList.remove('hidden');
  
  const txParams = pendingRequest.request.params[0];
  
  // Display transaction details
  document.getElementById('dappTxFrom').textContent = txParams.from || wallet?.address || '';
  document.getElementById('dappTxTo').textContent = txParams.to || '';
  document.getElementById('dappTxValue').textContent = txParams.value ? 
    `${ethers.formatEther(txParams.value)} ETH` : '0 ETH';
  document.getElementById('dappTxGas').textContent = txParams.gas || 'Auto';
  
  // Handle calldata
  const calldata = txParams.data || '0x';
  const calldataDisplay = document.getElementById('calldataDisplay');
  const swissKnifeLink = document.getElementById('swissKnifeLink');
  const toggleBtn = document.getElementById('toggleCalldata');
  const calldataSection = document.getElementById('calldataSection');
  
  if (calldataDisplay) {
    calldataDisplay.value = calldata;
  }
  
  if (swissKnifeLink && calldata !== '0x' && calldata.length > 2) {
    swissKnifeLink.href = '#';
    swissKnifeLink.style.display = 'inline-block';
    swissKnifeLink.onclick = (e) => {
      e.preventDefault();
      const url = `https://openchain.xyz/trace/ethereum?calldata=${calldata}`;
      if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
        chrome.runtime.sendMessage({ action: 'open_external', url });
      } else {
        window.open(url, '_blank', 'noopener,noreferrer');
      }
    };
  } else if (swissKnifeLink) {
    swissKnifeLink.style.display = 'none';
  }
  
  if (toggleBtn && calldataSection) {
    toggleBtn.onclick = () => {
      const isHidden = calldataSection.classList.contains('hidden');
      calldataSection.classList.toggle('hidden');
      toggleBtn.textContent = isHidden ? 'Hide' : 'Show';
    };
  }
  
  // Setup approve/reject handlers
  const approveBtn = document.getElementById('approveDapp');
  const rejectBtn = document.getElementById('rejectDapp');
  
  if (approveBtn) {
    approveBtn.onclick = async () => {
      if (!wallet) {
        showError('Please unlock your wallet first', 'Action');
        return;
      }
      
      try {
        // Send the transaction
        const tx = await wallet.sendTransaction({
          to: txParams.to,
          value: txParams.value || 0,
          data: txParams.data || '0x',
          gasLimit: txParams.gas,
          maxFeePerGas: txParams.maxFeePerGas,
          maxPriorityFeePerGas: txParams.maxPriorityFeePerGas
        });
        
        // Send response with transaction hash
        chrome.runtime.sendMessage({
          type: 'USER_RESPONSE',
          requestId: requestId,
          response: { result: tx.hash }
        });
        
        showToast(`Transaction sent: ${tx.hash.slice(0, 10)}...`);
        window.close();
      } catch (err) {
        chrome.runtime.sendMessage({
          type: 'USER_RESPONSE',
          requestId: requestId,
          response: { error: { code: -32000, message: err.message } }
        });
        
        showError(err, 'Transaction');
      }
    };
  }
  
  if (rejectBtn) {
    rejectBtn.onclick = () => {
      chrome.runtime.sendMessage({
        type: 'USER_RESPONSE',
        requestId: requestId,
        response: { error: { code: 4001, message: 'User rejected transaction' } }
      });
      
      window.close();
    };
  }
}

function handleSignRequest(requestId, pendingRequest) {
  const signDiv = document.getElementById('signRequest');
  const modalTitle = document.getElementById('dappModalTitle');
  const messageDiv = document.getElementById('signMessage');
  
  if (!signDiv || !modalTitle || !messageDiv) return;
  
  modalTitle.textContent = 'Sign Message';
  signDiv.classList.remove('hidden');
  
  const message = pendingRequest.request.params[0];
  messageDiv.textContent = message;
  
  // Setup approve/reject handlers
  const approveBtn = document.getElementById('approveDapp');
  const rejectBtn = document.getElementById('rejectDapp');
  
  if (approveBtn) {
    approveBtn.onclick = async () => {
      if (!wallet) {
        showError('Please unlock your wallet first', 'Action');
        return;
      }
      
      try {
        const signature = await wallet.signMessage(message);
        
        chrome.runtime.sendMessage({
          type: 'USER_RESPONSE',
          requestId: requestId,
          response: { result: signature }
        });
        
        window.close();
      } catch (err) {
        chrome.runtime.sendMessage({
          type: 'USER_RESPONSE',
          requestId: requestId,
          response: { error: { code: -32000, message: err.message } }
        });
        
        showError(err, 'Signing');
      }
    };
  }
  
  if (rejectBtn) {
    rejectBtn.onclick = () => {
      chrome.runtime.sendMessage({
        type: 'USER_RESPONSE',
        requestId: requestId,
        response: { error: { code: 4001, message: 'User rejected signature' } }
      });
      
      window.close();
    };
  }
}

async function loadCustomTokens() {
  try {
    const stored = localStorage.getItem("custom_tokens");
    if (stored) {
      customTokens = JSON.parse(stored);
      // Create TOKENS in specific order: defaults first, then custom
      TOKENS = {};
      // Add default tokens in order
      for (const key of Object.keys(DEFAULT_TOKENS)) {
        TOKENS[key] = DEFAULT_TOKENS[key];
      }
      // Add custom tokens
      for (const key of Object.keys(customTokens)) {
        if (!DEFAULT_TOKENS[key]) {
          TOKENS[key] = customTokens[key];
        }
      }
    } else {
      TOKENS = {};
      for (const key of Object.keys(DEFAULT_TOKENS)) {
        TOKENS[key] = DEFAULT_TOKENS[key];
      }
    }
  } catch (err) {
    customTokens = {};
    TOKENS = {};
    for (const key of Object.keys(DEFAULT_TOKENS)) {
      TOKENS[key] = DEFAULT_TOKENS[key];
    }
  }
}

function saveCustomToken(token) {
  customTokens[token.symbol] = token;
  TOKENS[token.symbol] = token;
  localStorage.setItem("custom_tokens", JSON.stringify(customTokens));
}

function loadTheme() {
  const theme = localStorage.getItem("theme") || "light";
  document.documentElement.setAttribute("data-theme", theme);
}

function toggleTheme() {
  const current = document.documentElement.getAttribute("data-theme");
  const next = current === "dark" ? "light" : "dark";
  document.documentElement.setAttribute("data-theme", next);
  localStorage.setItem("theme", next);
}

function loadRpcSettings() {
  const customRpc = localStorage.getItem("custom_rpc");

  document.querySelectorAll(".rpc-item").forEach((item) => {
    item.classList.remove("active");
    const itemRpc = item.dataset.rpc;

    if (itemRpc === "custom" && currentRpc === customRpc) {
      item.classList.add("active");
    } else if (itemRpc === currentRpc) {
      item.classList.add("active");
    }
  });

  if (customRpc) {
    document.getElementById("customRpcUrl").value = customRpc;
  }
}

async function initProvider() {
  try {
    // Add timeout for RPC connections
    const timeoutPromise = new Promise((_, reject) => 
      setManagedTimeout(() => reject(new Error('RPC timeout')), 5000)
    );
    
    provider = new ethers.JsonRpcProvider(currentRpc);
    await Promise.race([
      provider.getBlockNumber(),
      timeoutPromise
    ]);

    // Initialize zWallet contract
    zWalletContract = new ethers.Contract(
      ZWALLET_ADDRESS,
      ZWALLET_ABI,
      provider
    );
    
    // Initialize zQuoter contract once
    zQuoterContract = new ethers.Contract(
      ZQUOTER_ADDRESS,
      ZQUOTER_ABI,
      provider
    );

    // Connected to RPC
    loadRpcSettings();
    showToast("Connected to network");
  } catch (err) {
    
    // Try fallback
    for (const rpc of [
      "https://eth.llamarpc.com",
      "https://ethereum.publicnode.com",
    ]) {
      try {
        provider = new ethers.JsonRpcProvider(rpc);
        await provider.getBlockNumber();
        zWalletContract = new ethers.Contract(
          ZWALLET_ADDRESS,
          ZWALLET_ABI,
          provider
        );
        zQuoterContract = new ethers.Contract(
          ZQUOTER_ADDRESS,
          ZQUOTER_ABI,
          provider
        );
        currentRpc = rpc;
        localStorage.setItem("rpc_endpoint", rpc);
        loadRpcSettings();
        break;
      } catch (e) {
        continue;
      }
    }
    if (!provider) {
      showToast("Network connection failed");
    }
  }
}

function loadWallets() {
  const v2 = JSON.parse(localStorage.getItem(LS_WALLETS) || "[]");
  savedWallets = v2.map(({ address, label }) => ({ address, label }));
  updateWalletSelectorFrom(v2);
}

async function saveWallet(address, privateKey) {
  const pass = await securePasswordPrompt('Create Password', 'Create a strong password to encrypt your wallet:', true);
  if (!pass) return;
  const payload = await encryptPK(privateKey, pass, {
    aad: address.toLowerCase(),
  });
  const entry = {
    address,
    label: address.slice(0, 6) + "..." + address.slice(-4),
    crypto: payload,
  };
  const stored = JSON.parse(localStorage.getItem(LS_WALLETS) || "[]");
  if (!stored.find((w) => w.address === address)) {
    stored.push(entry);
    localStorage.setItem(LS_WALLETS, JSON.stringify(stored));
    localStorage.setItem(LS_LAST, address);
  }
  updateWalletSelectorFrom(stored);
}

function deleteWallet(address) {
  const list = JSON.parse(localStorage.getItem(LS_WALLETS) || "[]").filter(
    (w) => w.address.toLowerCase() !== address.toLowerCase()
  );
  localStorage.setItem(LS_WALLETS, JSON.stringify(list));
  updateWalletSelectorFrom(list);

  const last = localStorage.getItem(LS_LAST);
  if (last && last.toLowerCase() === address.toLowerCase()) {
    localStorage.removeItem(LS_LAST);
  }
  if (wallet && wallet.address.toLowerCase() === address.toLowerCase()) {
    // Clean up before removing wallet
    cleanupForWalletSwitch();
    wallet = null;
    document.getElementById("walletSection").classList.add("hidden");
    document.getElementById("balanceSection").classList.add("hidden");
  }
}

function updateWalletSelector() {
  const selector = document.getElementById("walletSelector");
  const selectorSection = document.getElementById("walletSelectorSection");

  selector.innerHTML = '<option value="">Select wallet...</option>';

  if (savedWallets.length > 0) {
    selectorSection.classList.remove("hidden");
    savedWallets.forEach((w) => {
      const option = document.createElement("option");
      option.value = w.address;
      option.textContent = w.label;
      if (wallet && wallet.address === w.address) {
        option.selected = true;
      }
      selector.appendChild(option);
    });
  } else {
    selectorSection.classList.add("hidden");
  }
}

function updateWalletSelectorFrom(list) {
  savedWallets = list.map(({ address, label }) => ({ address, label }));
  updateWalletSelector();
}

// Fetch ZAMM price from the AMM pool using constant product formula
async function fetchZAMMPrice() {
  try {
    // Use ZAMM_0 for ZAMM token price checking
    const zammContract = new ethers.Contract(
      ZAMM_0_ADDRESS,
      ZAMM_AMM_ABI,
      provider
    );
    
    // Get pool reserves
    const poolData = await zammContract.pools(ZAMM_POOL_ID);
    const reserve0 = Number(poolData[0]); // ETH reserves
    const reserve1 = Number(poolData[1]); // ZAMM reserves
    
    if (reserve0 === 0 || reserve1 === 0) {
      // ZAMM pool has no liquidity
      return { eth: 0, usd: 0 };
    }
    
    // Calculate price using constant product formula
    // Price of 1 ZAMM in ETH = reserve0 / reserve1
    const zammPriceInEth = safeDivide(reserve0, reserve1, 0);
    
    // Calculate USD price based on ETH price
    const zammPriceInUsd = zammPriceInEth * ethPrice;
    
    // Price and reserves calculated
    
    return {
      eth: zammPriceInEth,
      usd: zammPriceInUsd
    };
  } catch (err) {
    
    return { eth: 0, usd: 0 };
  }
}

/**
 * Show loading skeleton for token grids
 */
function showTokenLoadingSkeleton() {
  const tokenGrid = getCachedElement("tokenGrid");
  const sendTokenGrid = getCachedElement("sendTokenGrid");
  
  if (tokenGrid) {
    tokenGrid.innerHTML = `
      <div class="skeleton skeleton-row"></div>
      <div class="skeleton skeleton-row"></div>
      <div class="skeleton skeleton-row"></div>
    `;
  }
  
  if (sendTokenGrid) {
    sendTokenGrid.innerHTML = `
      <div class="skeleton skeleton-row"></div>
      <div class="skeleton skeleton-row"></div>
      <div class="skeleton skeleton-row"></div>
    `;
  }
}

// Fetch all balances using zWallet contract's batchView
async function fetchAllBalances() {
  if (!wallet || !provider || !zWalletContract) return;
  
  // Show loading state
  showTokenLoadingSkeleton();

  return ErrorBoundary.wrapAsync(async () => {
    // Prepare token addresses and ids for batchView
    const tokenAddresses = [];
    const tokenIds = [];
    const tokenSymbols = [];

    for (const [symbol, token] of Object.entries(TOKENS)) {
      if (token.isERC6909) {
        tokenAddresses.push(token.address);
        tokenIds.push(BigInt(token.id));
      } else {
        tokenAddresses.push(token.address || ethers.ZeroAddress);
        tokenIds.push(0);
      }
      tokenSymbols.push(symbol);
    }

    // Call batchView to get all data in one call
    const batchResult = await zWalletContract.batchView(
      wallet.address,
      tokenAddresses,
      tokenIds
    );
    
    // Destructure the results we need
    const ensName = batchResult[0];
    // const tokensOut = batchResult[1]; // Not used currently
    // const idsOut = batchResult[2]; // Not used currently
    // const kinds = batchResult[3]; // Token type indicators: 0=ETH, 20=ERC20, 72=ERC721, 69=ERC6909
    const rawBalances = batchResult[4];
    // const balances = batchResult[5]; // We calculate our own formatted balances
    const names = batchResult[6];
    const symbols = batchResult[7];
    const decimals = batchResult[8];
    const pricesETH = batchResult[9];
    // const pricesETHStr = batchResult[10]; // Not used currently
    const pricesUSDC = batchResult[11];
    // const pricesUSDCStr = batchResult[12]; // Not used currently
    
    // Update ENS name if found
    if (ensName) {
      // ENS name resolved
      // Display ENS name in the UI
      const ensNameEl = document.getElementById("ensName");
      if (ensNameEl) {
        ensNameEl.textContent = ensName;
      }
    }

    // Process the results
    currentBalances = {};
    tokenPrices = {};
    
    // First, find ETH price from the results (it will be in ETH's pricesUSDC)
    let ethPriceInUsd = 3500; // fallback
    const ethIndex = tokenSymbols.indexOf("ETH");
    if (ethIndex !== -1 && pricesUSDC[ethIndex]) {
      ethPriceInUsd = Number(pricesUSDC[ethIndex]) / 1e6;
      ethPrice = ethPriceInUsd; // Update global ethPrice
      
    }

    for (let i = 0; i < tokenSymbols.length; i++) {
      const symbol = tokenSymbols[i];
      const token = TOKENS[symbol];

      // Store balance
      currentBalances[symbol] = {
        raw: rawBalances[i],
        formatted: ethers.formatUnits(rawBalances[i], decimals[i]),
      };

      // Store prices - the contract already handles ETH/WETH/USDC special cases
      let priceInEth = Number(pricesETH[i]) / 1e18;
      let priceInUsd = Number(pricesUSDC[i]) / 1e6;

      // Only override for stablecoins that aren't USDC (since USDC is handled by contract)
      if (symbol === "USDT" || symbol === "DAI") {
        priceInUsd = 1.0; // Stablecoins are always $1
        // Calculate ETH price based on current ETH/USD rate
        if (ethPriceInUsd > 0) {
          priceInEth = safeDivide(1.0, ethPriceInUsd, 0); // 1 USD worth of ETH
        }
      } else if (symbol === "ZAMM") {
        // Fetch ZAMM price from the AMM pool
        const zammPrice = await fetchZAMMPrice();
        priceInEth = zammPrice.eth;
        priceInUsd = zammPrice.usd;
      }
      // The contract already correctly handles:
      // - ETH: priceETH = 1, priceUSDC from WETH
      // - WETH: priceETH = 1, priceUSDC from checkPrice
      // - USDC: priceUSDC = 1, priceETH from checkPriceInETH

      tokenPrices[symbol] = {
        eth: priceInEth,
        usd: priceInUsd,
      };

      // Update token metadata if needed
      if (!token.isCoin && (token.name === undefined || token.name === "")) {
        token.name = names[i] || symbol;
        token.symbol = symbols[i] || symbol;
        token.decimals = decimals[i];
      }
    }

    updateBalanceDisplay();
  }, 'Fetch Balances', async () => {
    // Fallback to individual fetches
    await fetchBalancesFallback();
  });
}

async function fetchBalancesFallback() {
  if (!wallet || !provider || !zWalletContract) return;

  // Get WETH price using zWallet contract (it has price checking built in)
  try {
    if (zWalletContract) {
      const [priceUSDC] = await zWalletContract.checkPrice(WETH_ADDRESS);
      ethPrice = Number(priceUSDC) / 1e6; // USDC has 6 decimals
      
    } else {
      ethPrice = 3500; // Fallback if contract not ready
    }
  } catch (err) {
    
    ethPrice = 3500; // Fallback
  }

  for (const [symbol, token] of Object.entries(TOKENS)) {
    try {
      const tokenAddress = token.address || ethers.ZeroAddress;
      const tokenId = token.isERC6909 ? BigInt(token.id) : 0;

      // Get balance
      const [raw] = await zWalletContract.getBalanceOf(
        wallet.address,
        tokenAddress,
        tokenId
      );

      currentBalances[symbol] = {
        raw: raw,
        formatted: ethers.formatUnits(raw, token.decimals || 18),
      };

      // Get prices - let the contract handle ETH/USDC special cases
      if (symbol === "USDT" || symbol === "DAI") {
        // Only override non-USDC stablecoins to exactly $1.00
        tokenPrices[symbol] = {
          eth: safeDivide(1.0, ethPrice, 0),
          usd: 1.0,
        };
      } else if (symbol === "ZAMM") {
        // Fetch ZAMM price from the AMM pool
        const zammPrice = await fetchZAMMPrice();
        tokenPrices[symbol] = zammPrice;
      } else {
        try {
          // The contract automatically handles:
          // - ETH: returns priceETH = 1e18, priceUSDC from WETH
          // - USDC: returns priceUSDC = 1e6, priceETH calculated
          const [priceETH] = await zWalletContract.checkPriceInETH(
            tokenAddress
          );
          const [priceUSDC] = await zWalletContract.checkPriceInETHToUSDC(
            tokenAddress
          );

          tokenPrices[symbol] = {
            eth: Number(priceETH) / 1e18,
            usd: Number(priceUSDC) / 1e6,
          };
        } catch (err) {
          
          tokenPrices[symbol] = { eth: 0, usd: 0 };
        }
      }
    } catch (err) {
      
      currentBalances[symbol] = { raw: 0n, formatted: "0" };
      tokenPrices[symbol] = { eth: 0, usd: 0 };
    }
  }

  updateBalanceDisplay();
}

function updateBalanceDisplay() {
  const tokenGrid = getCachedElement("tokenGrid");
  const sendTokenGrid = getCachedElement("sendTokenGrid");
  if (!tokenGrid || !sendTokenGrid) {
    console.error('Token grid elements not found');
    return;
  }

  // Use DocumentFragment for batched DOM updates
  const walletFragment = document.createDocumentFragment();
  const sendFragment = document.createDocumentFragment();

  let totalValue = 0;
  let totalETH = 0;

  // Use Object.keys to maintain insertion order
  const tokenKeys = Object.keys(TOKENS);
  
  // Pre-calculate all values
  const tokenData = tokenKeys.map(symbol => {
    const token = TOKENS[symbol];
    const balance = currentBalances[symbol] || { formatted: "0" };
    const price = tokenPrices[symbol] || { eth: 0, usd: 0 };
    const value = parseFloat(balance.formatted) * price.usd;
    
    return { symbol, token, balance, price, value };
  });

  // Process all tokens
  for (const { symbol, token, balance, price, value } of tokenData) {
    totalValue += value;
    
    // Calculate ETH value
    if (symbol === "ETH") {
      totalETH += parseFloat(balance.formatted);
    } else {
      totalETH += parseFloat(balance.formatted) * price.eth;
    }

    // Create row for wallet tab
    const walletRow = document.createElement("div");
    walletRow.className = "token-row";
    walletRow.dataset.symbol = symbol;

    // Special display logic for ETH vs other tokens
    let priceDisplay1 = "";
    let priceDisplay2 = "";

    if (symbol === "ETH") {
      // For ETH: show USD price per ETH and total value
      if (price.usd > 0) {
        priceDisplay1 = formatCurrency(price.usd) + "/ETH";
        priceDisplay2 = formatCurrency(value);
      } else {
        priceDisplay1 = "Price unavailable";
        priceDisplay2 = "$0.00";
      }
    } else {
      // For other tokens: show ETH ratio and USD value
      priceDisplay1 = `${price.eth.toFixed(6)} ETH`;
      priceDisplay2 = formatCurrency(value);
    }

    // Use template literal once for efficiency
    walletRow.innerHTML = `
  <div class="token-left">
    <div class="token-icon">${TOKEN_LOGOS[symbol] || generateCoinSVG(symbol)}</div>
    <div class="token-details">
      <div class="token-symbol">${esc(symbol)}</div>
      <div class="token-name">${esc(token.name || symbol)}</div>
    </div>
  </div>
  <div class="token-right">
    <div class="token-balance">${Number(balance.formatted).toFixed(4)}</div>
    <div class="token-prices">
      <span class="eth-price">${esc(priceDisplay1)}</span>
      <span class="usd-price">${esc(priceDisplay2)}</span>
    </div>
  </div>`;

    walletFragment.appendChild(walletRow);

    // Create row for send tab
    const sendRow = walletRow.cloneNode(true);
    if (symbol === selectedToken) {
      sendRow.classList.add("selected");
    }
    sendRow.addEventListener("click", () => selectToken(symbol));
    sendFragment.appendChild(sendRow);
  }

  // Batch update DOM
  domBatcher.add(() => {
    tokenGrid.innerHTML = "";
    sendTokenGrid.innerHTML = "";
    tokenGrid.appendChild(walletFragment);
    sendTokenGrid.appendChild(sendFragment);
    
    const portfolioTotal = getCachedElement("portfolioTotal");
    if (portfolioTotal) {
      portfolioTotal.innerHTML = `<div style="font-size: 20px; margin-bottom: 4px;">${formatCurrency(totalValue)}</div>
      <div style="font-size: 14px; color: var(--text-secondary);">${totalETH.toFixed(6)} ETH</div>`;
    }
  });
}

function selectToken(symbol) {
  selectedToken = symbol;
  // Optimize with for...of loop for better performance
  const rows = document.querySelectorAll("#sendTokenGrid .token-row");
  for (const row of rows) {
    row.classList.toggle("selected", row.dataset.symbol === symbol);
  }
  const label = getCachedElement("selectedTokenLabel");
  if (label) label.textContent = symbol;
  
  // Show/hide IOU mode for USDC
  const iouModeSection = document.getElementById("iouModeSection");
  const iouModeToggle = document.getElementById("iouModeToggle");
  if (symbol === "USDC") {
    iouModeSection?.classList.remove("hidden");
  } else {
    iouModeSection?.classList.add("hidden");
    // Reset IOU mode if switching away from USDC
    if (iouModeToggle && iouModeToggle.checked) {
      iouModeToggle.checked = false;
      // Trigger change event to reset UI
      iouModeToggle.dispatchEvent(new Event("change"));
    }
  }
  
  updateEstimatedTotal();
}

async function resolveENS(name) {
  if (!name.endsWith(".eth")) return null;

  // Use zWallet contract's ENS resolution if available
  if (zWalletContract) {
    try {
      const [owner, receiver] = await zWalletContract.whatIsTheAddressOf(name);
      // Return receiver if set, otherwise owner
      return receiver !== ethers.ZeroAddress ? receiver : owner !== ethers.ZeroAddress ? owner : null;
    } catch (err) {
      
    }
  }

  // Fallback to provider resolution
  try {
    return await provider.resolveName(name);
  } catch (err) {
    
    return null;
  }
}

async function updateGasPrices() {
  if (!provider) return;

  try {
    const feeData = await provider.getFeeData();

    // Get current base fee and add buffer for next block
    let baseFee = feeData.maxFeePerGas;
    let priorityFee = feeData.maxPriorityFeePerGas;

    // Fallback to reasonable defaults if not available
    if (!baseFee || baseFee === 0n) {
      baseFee = ethers.parseUnits("20", "gwei"); // 20 gwei fallback
    }
    if (!priorityFee || priorityFee === 0n) {
      priorityFee = ethers.parseUnits("1.5", "gwei"); // 1.5 gwei fallback
    }

    // More conservative multipliers
    gasPrices.slow = {
      maxFeePerGas: (baseFee * 95n) / 100n, // 95% of base (was 90%)
      maxPriorityFeePerGas: ethers.parseUnits("1", "gwei"), // Fixed 1 gwei for slow
    };

    gasPrices.normal = {
      maxFeePerGas: (baseFee * 110n) / 100n, // 110% buffer (was 100%)
      maxPriorityFeePerGas: priorityFee, // Keep suggested priority
    };

    gasPrices.fast = {
      maxFeePerGas: (baseFee * 125n) / 100n, // 125% buffer (was 120%)
      maxPriorityFeePerGas: (priorityFee * 120n) / 100n, // 120% priority (was 150%)
    };

    // Cap maximum gas prices to prevent overpaying
    const maxGasPrice = ethers.parseUnits("200", "gwei");
    const maxPriorityPrice = ethers.parseUnits("10", "gwei");

    for (const speed of ["slow", "normal", "fast"]) {
      if (gasPrices[speed].maxFeePerGas > maxGasPrice) {
        gasPrices[speed].maxFeePerGas = maxGasPrice;
      }
      if (gasPrices[speed].maxPriorityFeePerGas > maxPriorityPrice) {
        gasPrices[speed].maxPriorityFeePerGas = maxPriorityPrice;
      }
    }

    // Update display with null checks
    const slowPriceEl = document.getElementById("slowPrice");
    const normalPriceEl = document.getElementById("normalPrice");
    const fastPriceEl = document.getElementById("fastPrice");
    
    if (slowPriceEl) {
      slowPriceEl.textContent = (Number(gasPrices.slow.maxFeePerGas) / 1e9).toFixed(1);
    }
    if (normalPriceEl) {
      normalPriceEl.textContent = (Number(gasPrices.normal.maxFeePerGas) / 1e9).toFixed(1);
    }
    if (fastPriceEl) {
      fastPriceEl.textContent = (Number(gasPrices.fast.maxFeePerGas) / 1e9).toFixed(1);
    }

    await updateEstimatedTotal();
  } catch (err) {
    

    // Fallback to safe defaults on error
    const fallbackGas = ethers.parseUnits("30", "gwei");
    const fallbackPriority = ethers.parseUnits("2", "gwei");

    gasPrices.slow = {
      maxFeePerGas: ethers.parseUnits("20", "gwei"),
      maxPriorityFeePerGas: ethers.parseUnits("1", "gwei"),
    };
    gasPrices.normal = {
      maxFeePerGas: fallbackGas,
      maxPriorityFeePerGas: fallbackPriority,
    };
    gasPrices.fast = {
      maxFeePerGas: ethers.parseUnits("50", "gwei"),
      maxPriorityFeePerGas: ethers.parseUnits("3", "gwei"),
    };
  }
}

async function updateEstimatedTotal() {
  const amount = document.getElementById("amount").value || "0";
  const estimatedTotalEl = document.getElementById("estimatedTotal");
  if (!estimatedTotalEl) return;
  
  if (!wallet || !provider) {
    estimatedTotalEl.textContent = "--";
    return;
  }

  try {
    const token = TOKENS[selectedToken];
    const gasLimit =
      selectedToken === "ETH" ? 21000n : token?.isERC6909 ? 150000n : 100000n;

    const gasPrice = gasPrices[selectedGasSpeed]?.maxFeePerGas || 20000000000n;
    const gasCostEth = ethers.formatEther(gasLimit * gasPrice);
    const gasCostUsd = parseFloat(gasCostEth) * ethPrice;

    const tokenPrice = tokenPrices[selectedToken] || { eth: 0, usd: 0 };
    const amountUsd = parseFloat(amount) * tokenPrice.usd;

    estimatedTotalEl.textContent = `${amount} ${selectedToken} ($${amountUsd.toFixed(
      2
    )}) + Ξ${parseFloat(gasCostEth).toFixed(5)} gas ($${gasCostUsd.toFixed(
      2
    )})`;
  } catch (err) {
    
    estimatedTotalEl.textContent = amount + " " + selectedToken;
  }
}

async function calculateMaxAmount() {
  if (!wallet) return "0";

  const balance = currentBalances[selectedToken];
  if (!balance) return "0";

  if (selectedToken === "ETH") {
    const gasLimit = 21000n;
    const gasPrice = gasPrices[selectedGasSpeed]?.maxFeePerGas || 30000000000n;
    const gasCost = (gasLimit * gasPrice * 110n) / 100n; // 110% buffer (was 120%)

    if (balance.raw > gasCost) {
      return ethers.formatEther(balance.raw - gasCost);
    }
    return "0";
  }

  return balance.formatted;
}

async function fetchTransactionHistoryExtended() {
  if (!wallet || !provider) return;

  const loadingMsg = document.getElementById("txLoadingMessage");
  const loadMoreBtn = document.getElementById("loadMoreTxBtn");

  if (!loadingMsg) {
    
    return;
  }

  loadingMsg.textContent = "Loading 24 hours of transactions...";
  loadingMsg.classList.remove("hidden");
  if (loadMoreBtn) loadMoreBtn.classList.add("hidden");
  txHistory = [];

  const uniqueTxs = new Set();

  try {
    const currentBlock = await provider.getBlockNumber();
    // ~7200 blocks in 24 hours (12 sec per block)
    // We'll fetch in chunks of 999 blocks
    const totalBlocks = 7200;
    const chunkSize = 999;
    const chunks = Math.ceil(totalBlocks / chunkSize);
    
    for (let i = 0; i < chunks; i++) {
      const toBlock = currentBlock - (i * chunkSize);
      const fromBlock = Math.max(0, toBlock - chunkSize + 1);
      
      loadingMsg.textContent = `Loading transactions... (${i + 1}/${chunks})`;
      
      const promises = [];
      
      // Fetch each token's transfers for this chunk
      for (const [symbol, token] of Object.entries(TOKENS)) {
        if (!token.address) continue;
        
        if (token.isERC6909) {
          // Handle ERC6909 tokens - Transfer(address caller, address indexed sender, address indexed receiver, uint256 indexed id, uint256 amount)
          promises.push(
            Promise.all([
              provider.getLogs({
                address: token.address,
                fromBlock,
                toBlock,
                topics: [
                  ethers.id("Transfer(address,address,address,uint256,uint256)"),
                  ethers.zeroPadValue(wallet.address, 32), // sender (indexed)
                  null, // receiver can be anyone
                  ethers.zeroPadValue(BigInt(token.id), 32), // id (indexed)
                ],
              }).catch(() => []),
              provider.getLogs({
                address: token.address,
                fromBlock,
                toBlock,
                topics: [
                  ethers.id("Transfer(address,address,address,uint256,uint256)"),
                  null, // sender can be anyone
                  ethers.zeroPadValue(wallet.address, 32), // receiver (indexed)
                  ethers.zeroPadValue(BigInt(token.id), 32), // id (indexed)
                ],
              }).catch(() => [])
            ]).then(([sentLogs, receivedLogs]) => {
              // Process ERC6909 sent transactions
              for (const log of sentLogs) {
                // Data contains: caller (address) and amount (uint256)
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                  ["address", "uint256"],
                  log.data
                );
                const txKey = `${log.transactionHash}-${log.logIndex}`;
                if (!uniqueTxs.has(txKey)) {
                  uniqueTxs.add(txKey);
                  txHistory.push({
                    type: "send",
                    token: symbol,
                    amount: ethers.formatUnits(decoded[1], token.decimals),
                    hash: log.transactionHash,
                    block: log.blockNumber,
                    to: "0x" + log.topics[2].slice(26), // receiver is topic[2]
                    logIndex: log.logIndex,
                  });
                }
              }
              // Process ERC6909 received transactions
              for (const log of receivedLogs) {
                // Data contains: caller (address) and amount (uint256)
                const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                  ["address", "uint256"],
                  log.data
                );
                const txKey = `${log.transactionHash}-${log.logIndex}`;
                if (!uniqueTxs.has(txKey)) {
                  uniqueTxs.add(txKey);
                  txHistory.push({
                    type: "receive",
                    token: symbol,
                    amount: ethers.formatUnits(decoded[1], token.decimals),
                    hash: log.transactionHash,
                    block: log.blockNumber,
                    from: "0x" + log.topics[1].slice(26), // sender is topic[1]
                    logIndex: log.logIndex,
                  });
                }
              }
            })
          );
        } else {
          // Standard ERC20
          promises.push(
            Promise.all([
              provider.getLogs({
                address: token.address,
                fromBlock,
                toBlock,
                topics: [
                  ethers.id("Transfer(address,address,uint256)"),
                  ethers.zeroPadValue(wallet.address, 32),
                ],
              }).catch(() => []),
              provider.getLogs({
                address: token.address,
                fromBlock,
                toBlock,
                topics: [
                  ethers.id("Transfer(address,address,uint256)"),
                  null,
                  ethers.zeroPadValue(wallet.address, 32),
                ],
              }).catch(() => [])
            ]).then(([sentLogs, receivedLogs]) => {
              for (const log of sentLogs) {
                const txKey = `${log.transactionHash}-${log.logIndex}`;
                if (!uniqueTxs.has(txKey)) {
                  uniqueTxs.add(txKey);
                  const amount = ethers.formatUnits(log.data, token.decimals);
                  txHistory.push({
                    type: "send",
                    token: symbol,
                    amount,
                    hash: log.transactionHash,
                    block: log.blockNumber,
                    to: "0x" + log.topics[2].slice(26),
                    logIndex: log.logIndex,
                  });
                }
              }
              for (const log of receivedLogs) {
                const txKey = `${log.transactionHash}-${log.logIndex}`;
                if (!uniqueTxs.has(txKey)) {
                  uniqueTxs.add(txKey);
                  const amount = ethers.formatUnits(log.data, token.decimals);
                  txHistory.push({
                    type: "receive",
                    token: symbol,
                    amount,
                    hash: log.transactionHash,
                    block: log.blockNumber,
                    from: "0x" + log.topics[1].slice(26),
                    logIndex: log.logIndex,
                  });
                }
              }
            })
          );
        }
      }
      
      await Promise.all(promises);
    }
    
    // Sort by block number and log index
    txHistory.sort((a, b) => {
      if (b.block !== a.block) return b.block - a.block;
      return (b.logIndex || 0) - (a.logIndex || 0);
    });

    displayTransactions();
  } catch (err) {
    
    if (loadingMsg) loadingMsg.textContent = "Error loading extended history";
    if (loadMoreBtn) loadMoreBtn.classList.remove("hidden");
  }
}

async function fetchTransactionHistory() {
  if (!wallet || !provider) return;

  const txList = document.getElementById("txList");
  const loadingMsg = document.getElementById("txLoadingMessage");

  loadingMsg.textContent = "Loading recent transactions (last ~3 hours)...";
  txList.classList.add("hidden");
  txHistory = [];

  // Use a Set to track unique transactions
  const uniqueTxs = new Set();

  try {
    // Get block number for limiting search
    const currentBlock = await provider.getBlockNumber();
    // Use 999 blocks to stay under RPC limit of 1000
    // This is approximately 3.3 hours of Ethereum blocks (12 sec per block)
    const fromBlock = Math.max(0, currentBlock - 999);

    // Parallel fetch all logs
    const promises = [];
    
    // Fetch token transfers for each token in parallel
    for (const [symbol, token] of Object.entries(TOKENS)) {
      if (!token.address) continue; // Skip ETH

      // Handle ERC6909 tokens differently
      if (token.isERC6909) {
        // ERC6909 uses Transfer event with 5 parameters: Transfer(address caller, address indexed sender, address indexed receiver, uint256 indexed id, uint256 amount)
        promises.push(
          Promise.all([
            provider.getLogs({
              address: token.address,
              fromBlock,
              toBlock: currentBlock,
              topics: [
                ethers.id("Transfer(address,address,address,uint256,uint256)"),
                ethers.zeroPadValue(wallet.address, 32), // sender (indexed)
                null, // receiver can be anyone
                ethers.zeroPadValue(BigInt(token.id), 32), // id (indexed)
              ],
            }),
            provider.getLogs({
              address: token.address,
              fromBlock,
              toBlock: currentBlock,
              topics: [
                ethers.id("Transfer(address,address,address,uint256,uint256)"),
                null, // sender can be anyone
                ethers.zeroPadValue(wallet.address, 32), // receiver (indexed)
                ethers.zeroPadValue(BigInt(token.id), 32), // id (indexed)
              ],
            })
          ]).then(([sentLogs, receivedLogs]) => {
            // Process ERC6909 sent
            for (const log of sentLogs) {
              // Data contains: caller (address) and amount (uint256)
              const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                ["address", "uint256"],
                log.data
              );
              const txKey = `${log.transactionHash}-${log.logIndex}`;
              if (!uniqueTxs.has(txKey)) {
                uniqueTxs.add(txKey);
                txHistory.push({
                  type: "send",
                  token: symbol,
                  amount: ethers.formatUnits(decoded[1], token.decimals),
                  hash: log.transactionHash,
                  block: log.blockNumber,
                  to: "0x" + log.topics[2].slice(26), // receiver is topic[2]
                  logIndex: log.logIndex,
                });
              }
            }
            // Process ERC6909 received
            for (const log of receivedLogs) {
              // Data contains: caller (address) and amount (uint256)
              const decoded = ethers.AbiCoder.defaultAbiCoder().decode(
                ["address", "uint256"],
                log.data
              );
              const txKey = `${log.transactionHash}-${log.logIndex}`;
              if (!uniqueTxs.has(txKey)) {
                uniqueTxs.add(txKey);
                txHistory.push({
                  type: "receive",
                  token: symbol,
                  amount: ethers.formatUnits(decoded[1], token.decimals),
                  hash: log.transactionHash,
                  block: log.blockNumber,
                  from: "0x" + log.topics[1].slice(26), // sender is topic[1]
                  logIndex: log.logIndex,
                });
              }
            }
          }).catch(() => {
            // Ignore errors for individual token fetches
          })
        );
      } else {
        // Standard ERC20 transfers
        promises.push(
          Promise.all([
            provider.getLogs({
              address: token.address,
              fromBlock,
              toBlock: currentBlock,
              topics: [
                ethers.id("Transfer(address,address,uint256)"),
                ethers.zeroPadValue(wallet.address, 32),
              ],
            }),
            provider.getLogs({
              address: token.address,
              fromBlock,
              toBlock: currentBlock,
              topics: [
                ethers.id("Transfer(address,address,uint256)"),
                null,
                ethers.zeroPadValue(wallet.address, 32),
              ],
            })
          ]).then(([sentLogs, receivedLogs]) => {
            // Process sent
            for (const log of sentLogs) {
              const txKey = `${log.transactionHash}-${log.logIndex}`;
              if (!uniqueTxs.has(txKey)) {
                uniqueTxs.add(txKey);
                const amount = ethers.formatUnits(log.data, token.decimals);
                txHistory.push({
                  type: "send",
                  token: symbol,
                  amount,
                  hash: log.transactionHash,
                  block: log.blockNumber,
                  to: "0x" + log.topics[2].slice(26),
                  logIndex: log.logIndex,
                });
              }
            }
            // Process received
            for (const log of receivedLogs) {
              const txKey = `${log.transactionHash}-${log.logIndex}`;
              if (!uniqueTxs.has(txKey)) {
                uniqueTxs.add(txKey);
                const amount = ethers.formatUnits(log.data, token.decimals);
                txHistory.push({
                  type: "receive",
                  token: symbol,
                  amount,
                  hash: log.transactionHash,
                  block: log.blockNumber,
                  from: "0x" + log.topics[1].slice(26),
                  logIndex: log.logIndex,
                });
              }
            }
          }).catch(() => {
            // Ignore errors for individual token fetches
          })
        );
      }
    }

    // Wait for all fetches to complete
    await Promise.all(promises);

    // Sort by block number and log index
    txHistory.sort((a, b) => {
      if (b.block !== a.block) return b.block - a.block;
      return (b.logIndex || 0) - (a.logIndex || 0);
    });

    // Display transactions
    displayTransactions();
  } catch (err) {
    
    loadingMsg.textContent = "Error loading transactions";
  }
}

function displayTransactions() {
  const txList = document.getElementById("txList");
  const loadingMsg = document.getElementById("txLoadingMessage");
  const loadMoreBtn = document.getElementById("loadMoreTxBtn");

  if (!txList || !loadingMsg) {
    
    return;
  }

  if (txHistory.length === 0) {
    loadingMsg.textContent = "No transactions found in the last 3 hours";
    txList.classList.add("hidden");
    if (loadMoreBtn) loadMoreBtn.classList.remove("hidden");
    return;
  }

  loadingMsg.classList.add("hidden");
  txList.classList.remove("hidden");
  if (loadMoreBtn) loadMoreBtn.classList.remove("hidden");
  txList.innerHTML = "";

  // Display max 100 most recent
  const displayTxs = txHistory.slice(0, 100);

  for (const tx of displayTxs) {
    const item = document.createElement("div");
    item.className = "tx-item";

    item.innerHTML = `
                    <span class="tx-type ${tx.type}">${tx.type}</span>
                    <div class="tx-details">
                        <a class="tx-hash" data-hash="${tx.hash}" href="#" title="View on Etherscan">${tx.hash.slice(0, 10)}... ↗</a>
                        <div style="font-size: 10px; color: var(--text-secondary);">
                            ${
                              tx.type === "send"
                                ? "To: " + tx.to?.slice(0, 8) + "..."
                                : "From: " + tx.from?.slice(0, 8) + "..."
                            }
                        </div>
                    </div>
                    <div class="tx-amount">
                        ${tx.type === "send" ? "-" : "+"}${parseFloat(
      tx.amount
    ).toFixed(4)} ${tx.token}
                    </div>
                `;

    // Add click handler to the hash link
    const hashLink = item.querySelector('.tx-hash');
    if (hashLink) {
      hashLink.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const hash = hashLink.dataset.hash;
        
        // Use Chrome API to open in new tab for extension compatibility
        if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage({
            action: 'open_external',
            url: `https://etherscan.io/tx/${hash}`
          });
        } else {
          window.open(
            `https://etherscan.io/tx/${hash}`,
            "_blank",
            "noopener,noreferrer"
          );
        }
      });
    }

    txList.appendChild(item);
  }
}

function esc(s) {
  return String(s).replace(
    /[&<>"']/g,
    (c) =>
      ({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
      }[c])
  );
}

window.addEventListener("beforeunload", () => {
  // Clean up all event listeners and timers
  cleanupEventListeners();
  wallet = null;
});
function lockWallet() {
  wallet = null;
  showToast("Locked");
}

function showEtherscanLink(txHash) {
  const status = document.getElementById("txStatus");
  
  // Create container for multiple links
  const linksContainer = document.createElement("div");
  linksContainer.style.cssText = "margin-top: 8px; display: flex; gap: 12px; flex-wrap: wrap;";
  
  // Etherscan link
  const etherscanLink = document.createElement("a");
  etherscanLink.href = `#`;
  etherscanLink.className = "etherscan-link";
  etherscanLink.textContent = "Etherscan →";
  etherscanLink.style.cssText = "color: var(--accent); text-decoration: underline; font-size: 12px;";
  etherscanLink.addEventListener('click', (e) => {
    e.preventDefault();
    const url = `https://etherscan.io/tx/${txHash}`;
    if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
      chrome.runtime.sendMessage({ action: 'open_external', url });
    } else {
      window.open(url, '_blank', 'noopener,noreferrer');
    }
  });
  
  // Transaction decoder link (Swiss Knife style)
  const decoderLink = document.createElement("a");
  decoderLink.href = `#`;
  decoderLink.className = "decoder-link";
  decoderLink.textContent = "Decode →";
  decoderLink.style.cssText = "color: var(--accent); text-decoration: underline; font-size: 12px;";
  decoderLink.addEventListener('click', (e) => {
    e.preventDefault();
    const url = `https://openchain.xyz/trace/ethereum/${txHash}`;
    if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
      chrome.runtime.sendMessage({ action: 'open_external', url });
    } else {
      window.open(url, '_blank', 'noopener,noreferrer');
    }
  });
  
  // Tenderly link for detailed debugging
  const tenderlyLink = document.createElement("a");
  tenderlyLink.href = `#`;
  tenderlyLink.className = "tenderly-link";
  tenderlyLink.textContent = "Debug →";
  tenderlyLink.style.cssText = "color: var(--accent); text-decoration: underline; font-size: 12px;";
  tenderlyLink.addEventListener('click', (e) => {
    e.preventDefault();
    const url = `https://dashboard.tenderly.co/tx/mainnet/${txHash}`;
    if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
      chrome.runtime.sendMessage({ action: 'open_external', url });
    } else {
      window.open(url, '_blank', 'noopener,noreferrer');
    }
  });
  
  linksContainer.appendChild(etherscanLink);
  linksContainer.appendChild(decoderLink);
  linksContainer.appendChild(tenderlyLink);
  status.appendChild(linksContainer);
}

function showToast(message, duration = 3000, type = 'success') {
  const toast = document.getElementById("toast");
  if (!toast) return;
  
  toast.textContent = message;
  toast.classList.remove("error", "warning", "success");
  toast.classList.add("show", type);
  setManagedTimeout(() => toast.classList.remove("show"), duration);
}

// Function to show user-friendly error messages
function showError(error, context = '') {
  let message = '';
  let errorType = 'error';
  
  // Parse error message
  const errorStr = error?.message || error?.toString() || 'Unknown error';
  
  // Handle common blockchain errors with user-friendly messages
  if (errorStr.includes('user rejected') || errorStr.includes('User denied') || errorStr.includes('User rejected')) {
    message = 'Transaction cancelled';
    errorType = 'warning';
  } else if (errorStr.includes('insufficient funds') || errorStr.includes('insufficient balance')) {
    message = 'Insufficient balance for this transaction';
  } else if (errorStr.includes('nonce too low') || errorStr.includes('already known')) {
    message = 'Transaction already submitted. Please wait...';
    errorType = 'warning';
  } else if (errorStr.includes('replacement transaction') || errorStr.includes('was replaced')) {
    message = 'Transaction updated successfully';
    errorType = 'warning';
  } else if (errorStr.includes('gas required exceeds') || errorStr.includes('out of gas')) {
    message = 'Transaction requires more gas than available';
  } else if (errorStr.includes('execution reverted')) {
    message = 'Transaction would fail. Please check your input';
  } else if (errorStr.includes('network') || errorStr.includes('timeout')) {
    message = 'Network error. Please try again';
  } else if (errorStr.includes('Invalid RPC')) {
    message = 'Invalid RPC URL';
  } else if (errorStr.includes('Wrong password') || errorStr.includes('incorrect password')) {
    message = 'Incorrect password';
  } else if (errorStr.includes('Invalid private key')) {
    message = 'Invalid private key format';
  } else {
    // For other errors, try to extract a meaningful part
    if (context) {
      message = `${context} failed`;
    } else {
      // Clean up technical jargon
      message = errorStr
        .replace(/Error: /gi, '')
        .replace(/\(.*?\)/g, '')
        .replace(/\[.*?\]/g, '')
        .substring(0, 100);
    }
  }
  
  showToast(message, 3000, errorType);
}

// Show QR code modal
function showQRModal(address) {
  const modal = document.getElementById("qrModal");
  const qrImage = document.getElementById("qrCodeImage");
  const qrAddress = document.getElementById("qrAddress");
  
  if (!modal || !qrImage || !qrAddress) return;
  
  // Generate QR code
  if (window.zWalletVisual && window.zWalletVisual.generateSimpleQR) {
    const qrDataUrl = window.zWalletVisual.generateSimpleQR(`ethereum:${address}`, 256);
    qrImage.src = qrDataUrl;
  }
  
  // Display address
  qrAddress.textContent = address;
  
  // Setup modal buttons
  const closeBtn = document.getElementById("qrModalClose");
  const downloadBtn = document.getElementById("downloadQR");
  const copyBtn = document.getElementById("copyQRAddress");
  
  if (closeBtn) {
    closeBtn.onclick = () => modal.classList.add("hidden");
  }
  
  if (downloadBtn) {
    downloadBtn.onclick = () => {
      const link = document.createElement("a");
      link.download = `zWallet-${address.slice(0, 8)}.png`;
      link.href = qrImage.src;
      link.click();
    };
  }
  
  if (copyBtn) {
    copyBtn.onclick = () => copyToClipboard(address, "address");
  }
  
  // Show modal
  modal.classList.remove("hidden");
  
  // Close on outside click
  modal.onclick = (e) => {
    if (e.target === modal) {
      modal.classList.add("hidden");
    }
  };
}

// Modal Management Helpers
function showModal(modalId, options = {}) {
  const modal = document.getElementById(modalId);
  if (!modal) return;
  
  // Remove hidden class with animation
  modal.classList.remove('hidden');
  
  // Add ESC key listener
  if (options.closeOnEsc !== false) {
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        hideModal(modalId);
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  }
  
  // Focus first input if available
  if (options.autoFocus !== false) {
    setTimeout(() => {
      const firstInput = modal.querySelector('input:not([type="hidden"]), textarea, select');
      if (firstInput) firstInput.focus();
    }, 100);
  }
}

function hideModal(modalId) {
  const modal = document.getElementById(modalId);
  if (!modal) return;
  
  modal.classList.add('hidden');
}

// Button Loading State Helper
function setButtonLoading(buttonId, loading = true) {
  const button = document.getElementById(buttonId);
  if (!button) return;
  
  if (loading) {
    button.classList.add('loading');
    button.disabled = true;
    button.dataset.originalText = button.textContent;
  } else {
    button.classList.remove('loading');
    button.disabled = false;
    if (button.dataset.originalText) {
      button.textContent = button.dataset.originalText;
    }
  }
}

// Debounce Helper for Better Performance
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Throttle Helper for Rate Limiting
function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

async function copyToClipboard(text, type) {
  try {
    // Try modern Clipboard API first
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      showToast(type === "address" ? "Address copied!" : "Private key copied!");
    } else {
      // Fallback for non-secure contexts or older browsers
      // Create a temporary textarea element
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.style.position = "fixed";
      textarea.style.left = "-999999px";
      textarea.style.top = "-999999px";
      document.body.appendChild(textarea);
      textarea.focus();
      textarea.select();
      
      // Try to use the Selection API instead of execCommand
      try {
        const range = document.createRange();
        range.selectNodeContents(textarea);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        
        // Attempt to write to clipboard using the selected text
        const blob = new Blob([text], { type: 'text/plain' });
        const data = [new ClipboardItem({ 'text/plain': blob })];
        await navigator.clipboard.write(data);
        document.body.removeChild(textarea);
        showToast(type === "address" ? "Address copied!" : "Private key copied!");
      } catch (selectionErr) {
        // Last resort - deprecated but still works in some browsers
        document.body.removeChild(textarea);
        throw new Error("Copy not supported");
      }
    }
  } catch (err) {
    // Final fallback - show the text for manual copying
    showToast("Copy failed - please copy manually");
    
    // For private keys, we could show a modal with the text selected
    if (type === "privateKey") {
      // Create a modal to show the private key for manual copying
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: var(--bg-secondary);
        padding: 20px;
        border-radius: 8px;
        z-index: 10000;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      `;
      modal.innerHTML = `
        <p style="margin-bottom: 10px;">Copy your private key:</p>
        <input type="text" value="${escapeHtml(text)}" readonly style="width: 100%; padding: 8px;" />
        <button onclick="this.parentElement.remove()" style="margin-top: 10px; width: 100%;">Close</button>
      `;
      document.body.appendChild(modal);
      modal.querySelector('input').select();
    }
  }
}

async function exportEncryptedKey() {
  if (!wallet) return;

  try {
    const password = await securePasswordPrompt('Create Password', 'Create a strong password to encrypt your imported wallet:', true);
    if (!password) return;

    // Encrypt the private key
    const encrypted = await encryptPK(wallet.privateKey, password, {
      aad: wallet.address.toLowerCase()
    });

    const exportData = {
      version: 2,
      address: wallet.address,
      encrypted: encrypted,
      timestamp: new Date().toISOString()
    };

    const blob = new Blob([JSON.stringify(exportData, null, 2)], { 
      type: "application/json" 
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `zWallet-encrypted-${wallet.address.slice(2, 8)}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showToast("Encrypted key exported!");
  } catch (err) {
    
    showToast("Export failed");
  }
}

async function displayWallet() {
  document.getElementById("walletSection").classList.remove("hidden");
  document.getElementById("balanceSection").classList.remove("hidden");

  const address = wallet.address;
  document.getElementById("address").textContent =
    address.slice(0, 6) + "..." + address.slice(-4);
  document.getElementById("address").title = address;
  
  // Set Etherscan link
  const etherscanLink = document.getElementById("etherscanLink");
  if (etherscanLink) {
    etherscanLink.href = `https://etherscan.io/address/${address}`;
  }
  
  // Generate and display blockie avatar
  if (window.zWalletVisual && window.zWalletVisual.createBlockie) {
    const blockieAvatar = document.getElementById("blockieAvatar");
    if (blockieAvatar) {
      blockieAvatar.src = window.zWalletVisual.createBlockie(address, 128);
    }
  }
  
  // Setup QR button
  const qrBtn = document.getElementById("qrBtn");
  if (qrBtn) {
    qrBtn.onclick = () => showQRModal(address);
  }

  // Private key display moved to Settings tab

  // ENS name is already fetched in batchView and displayed
  // No need for additional lookup here

  // Fetch balances and gas prices in parallel
  await Promise.all([
    fetchAllBalances(),
    updateGasPrices()
  ]);

  if (document.getElementById("autoRefresh").checked) {
    clearManagedInterval(autoRefreshInterval);
    autoRefreshInterval = setManagedInterval(() => {
      fetchAllBalances();
      updateGasPrices();
    }, 15000);
  }
}

async function addCustomToken(tokenAddress, tokenId = null) {
  if (!zWalletContract) return null;

  try {
    // Validate address
    if (!ethers.isAddress(tokenAddress)) {
      throw new Error("Invalid address");
    }

    let isERC6909 = false;
    let token;

    // Check if token ID is provided, suggesting ERC6909
    if (tokenId && tokenId !== "") {
      // Check if it's actually ERC6909
      isERC6909 = await zWalletContract.isERC6909(tokenAddress);
      
      if (!isERC6909) {
        throw new Error("Token ID provided but contract is not ERC6909");
      }

      // For ERC6909, we may not have per-ID metadata
      const [name, symbol, decimals] = await zWalletContract.getMetadata(
        tokenAddress
      );

      // Create unique symbol for this ID
      const idSymbol = symbol ? `${symbol.toUpperCase()}_${tokenId}` : `ID_${tokenId}`;
      
      token = {
        address: tokenAddress,
        symbol: idSymbol,
        name: name ? `${name} ID ${tokenId}` : `Token ID ${tokenId}`,
        decimals: decimals || 18,
        isERC6909: true,
        id: tokenId,
      };
    } else {
      // Check if it's ERC6909 without ID
      isERC6909 = await zWalletContract.isERC6909(tokenAddress);
      
      if (isERC6909) {
        throw new Error("This is an ERC6909 contract - please provide a token ID");
      }

      // Standard ERC20 token
      const [name, symbol, decimals] = await zWalletContract.getMetadata(
        tokenAddress
      );

      if (!symbol || symbol === "") {
        throw new Error("Could not fetch token metadata");
      }

      token = {
        address: tokenAddress,
        symbol: symbol.toUpperCase(),
        name: name || symbol,
        decimals: decimals,
      };
    }

    // Check if already exists
    if (TOKENS[token.symbol]) {
      throw new Error("Token already exists");
    }

    return token;
  } catch (err) {
    
    throw err;
  }
}

async function sendTransaction() {
  const toInput = sanitizeInput(document.getElementById("toAddress").value);
  const amountInput = sanitizeInput(document.getElementById("amount").value);
  const status = document.getElementById("txStatus");

  if (!toInput || !amountInput || !wallet) {
    status.innerHTML = '<div class="status error">Fill all fields</div>';
    return;
  }

  // Ensure wallet is connected to provider
  if (!wallet.provider) {
    wallet = wallet.connect(provider);
  }

  // Validate recipient address
  let toAddress = toInput;
  let addressValidation;
  
  if (toInput.endsWith(".eth")) {
    // Validate ENS name first
    const ensValidation = InputValidator.validateENS(toInput);
    if (!ensValidation.valid) {
      status.innerHTML = `<div class="status error">${ensValidation.error}</div>`;
      return;
    }
    
    status.innerHTML = '<div class="status">Resolving ENS...</div>';
    toAddress = await resolveENS(toInput);
    if (!toAddress) {
      status.innerHTML = '<div class="status error">ENS name not found</div>';
      return;
    }
    
    // Validate resolved address
    addressValidation = InputValidator.validateAddress(toAddress);
  } else {
    // Direct address validation
    addressValidation = InputValidator.validateAddress(toInput);
    if (addressValidation.valid) {
      toAddress = addressValidation.address; // Use checksummed address
    }
  }
  
  if (!addressValidation || !addressValidation.valid) {
    status.innerHTML = `<div class="status error">${addressValidation?.error || 'Invalid address'}</div>`;
    return;
  }
  
  // Validate amount
  const token = TOKENS[selectedToken];
  const balance = currentBalances[selectedToken];
  const amountValidation = InputValidator.validateAmount(
    amountInput,
    token?.decimals || 18,
    balance?.formatted
  );
  
  if (!amountValidation.valid) {
    status.innerHTML = `<div class="status error">${amountValidation.error}</div>`;
    return;
  }
  
  const amount = amountValidation.formatted;

  // Calculate values for confirmation
  const gasSettings = gasPrices[selectedGasSpeed] || gasPrices.normal;
  const gasLimit =
    selectedToken === "ETH" ? 21000n : token.isERC6909 ? 150000n : 100000n;
  const gasPrice = gasSettings.maxFeePerGas || 20000000000n;
  const gasCost = gasLimit * gasPrice;
  const gasCostEth = ethers.formatEther(gasCost);
  const gasCostUsd = parseFloat(gasCostEth) * ethPrice;

  const tokenPrice = tokenPrices[selectedToken] || { eth: 0, usd: 0 };
  const amountUsd = parseFloat(amount) * tokenPrice.usd;
  const totalUsd = amountUsd + gasCostUsd;

  // Balance already checked in validation above
  // Double-check ETH balance for gas
  if (!balance || parseFloat(balance.formatted) < parseFloat(amount)) {
    status.innerHTML = '<div class="status error">Insufficient balance</div>';
    return;
  }

  // Check ETH balance for gas
  const ethBalance = await provider.getBalance(wallet.address);
  if (ethBalance < gasCost) {
    status.innerHTML =
      '<div class="status error">Insufficient ETH for gas</div>';
    return;
  }

  // Populate confirmation modal
  document.getElementById("confirmToken").textContent = selectedToken;
  document.getElementById(
    "confirmAmount"
  ).textContent = `${amount} ${selectedToken}`;
  document.getElementById("confirmTo").textContent = toInput.endsWith(".eth")
    ? `${toInput} (${toAddress.slice(0, 6)}...${toAddress.slice(-4)})`
    : `${toAddress.slice(0, 6)}...${toAddress.slice(-4)}`;
  document.getElementById(
    "confirmValueUSD"
  ).textContent = `$${amountUsd.toFixed(2)}`;
  document.getElementById("confirmGas").textContent = `Ξ${parseFloat(
    gasCostEth
  ).toFixed(5)} ($${gasCostUsd.toFixed(2)})`;
  document.getElementById("confirmTotal").textContent = `$${totalUsd.toFixed(
    2
  )}`;

  // Prepare transaction calldata using zWallet helpers
  let calldata = '0x';
  if (selectedToken === 'ETH') {
    // ETH transfers have no calldata
    calldata = '0x';
  } else {
    const token = TOKENS[selectedToken];
    const amountWei = ethers.parseUnits(amount.toString(), token.decimals);
    
    if (token.isERC6909) {
      // Use zWallet helper for ERC6909 transfer
      calldata = await zWalletContract.getERC6909Transfer(
        toAddress,
        BigInt(token.id),
        amountWei
      );
    } else {
      // Use zWallet helper for ERC20 transfer
      calldata = await zWalletContract.getERC20Transfer(
        toAddress,
        amountWei
      );
    }
  }

  // Setup calldata display
  const calldataDisplay = document.getElementById('sendCalldataDisplay');
  const swissKnifeLink = document.getElementById('sendSwissKnifeLink');
  const toggleBtn = document.getElementById('toggleSendCalldata');
  const calldataSection = document.getElementById('sendCalldataSection');
  
  if (calldataDisplay) {
    calldataDisplay.value = calldata;
  }
  
  if (swissKnifeLink) {
    if (calldata !== '0x' && calldata.length > 2) {
      swissKnifeLink.href = '#';
      swissKnifeLink.style.display = 'inline-block';
      swissKnifeLink.onclick = (e) => {
        e.preventDefault();
        const url = `https://openchain.xyz/trace/ethereum?calldata=${calldata}`;
        if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage({ action: 'open_external', url });
        } else {
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      };
    } else {
      swissKnifeLink.style.display = 'none';
    }
  }
  
  if (toggleBtn && calldataSection) {
    // Reset state
    calldataSection.classList.add('hidden');
    toggleBtn.textContent = 'Show';
    
    // Add click handler (remove old one first to avoid duplicates)
    const newToggleBtn = toggleBtn.cloneNode(true);
    toggleBtn.parentNode.replaceChild(newToggleBtn, toggleBtn);
    
    newToggleBtn.onclick = () => {
      const isHidden = calldataSection.classList.contains('hidden');
      calldataSection.classList.toggle('hidden');
      newToggleBtn.textContent = isHidden ? 'Hide' : 'Show';
    };
  }

  // Show modal
  const modal = document.getElementById("txConfirmModal");
  modal.classList.remove("hidden");

  // Create promise for user confirmation
  const userConfirmed = await new Promise((resolve) => {
    const confirmBtn = document.getElementById("confirmSend");
    const cancelBtn = document.getElementById("cancelSend");
    const closeBtn = document.getElementById("modalClose");

    const cleanup = () => {
      confirmBtn.removeEventListener("click", handleConfirm);
      cancelBtn.removeEventListener("click", handleCancel);
      closeBtn.removeEventListener("click", handleCancel);
      modal.classList.add("hidden");
    };

    const handleConfirm = () => {
      cleanup();
      resolve(true);
    };

    const handleCancel = () => {
      cleanup();
      resolve(false);
    };

    confirmBtn.addEventListener("click", handleConfirm);
    cancelBtn.addEventListener("click", handleCancel);
    closeBtn.addEventListener("click", handleCancel);
  });

  if (!userConfirmed) {
    status.innerHTML = '<div class="status">Transaction cancelled</div>';
    return;
  }

  try {
    status.innerHTML = '<div class="status">Preparing transaction...</div>';
    document.getElementById("sendBtn").disabled = true;

    // Get the current nonce to prevent replay attacks
    const nonce = await wallet.getNonce();
    
    let tx;
    if (selectedToken === "ETH") {
      // Send ETH directly - no calldata needed
      tx = await wallet.sendTransaction({
        to: toAddress,
        value: ethers.parseEther(amount),
        gasLimit: 21000,
        maxFeePerGas: gasSettings.maxFeePerGas,
        maxPriorityFeePerGas: gasSettings.maxPriorityFeePerGas,
        nonce: nonce,
      });
    } else if (token.isERC6909) {
      // For ERC6909 tokens
      const amountWei = ethers.parseUnits(amount, token.decimals || 18);

      // Get the transfer calldata from zWallet
      const transferData = await zWalletContract.getERC6909Transfer(
        toAddress,
        BigInt(token.id),
        amountWei
      );

      // Send to the TOKEN contract with the calldata
      tx = await wallet.sendTransaction({
        to: token.address,
        data: transferData,
        gasLimit: 150000,
        maxFeePerGas: gasSettings.maxFeePerGas,
        maxPriorityFeePerGas: gasSettings.maxPriorityFeePerGas,
        nonce: nonce,
      });
    } else {
      // For ERC20 tokens
      const amountWei = ethers.parseUnits(amount, token.decimals || 18);

      // Get the transfer calldata from zWallet
      const transferData = await zWalletContract.getERC20Transfer(
        toAddress,
        amountWei
      );

      // Send to the TOKEN contract with the calldata
      tx = await wallet.sendTransaction({
        to: token.address,
        data: transferData,
        gasLimit: 100000,
        maxFeePerGas: gasSettings.maxFeePerGas,
        maxPriorityFeePerGas: gasSettings.maxPriorityFeePerGas,
        nonce: nonce,
      });
    }

    status.innerHTML = `<div class="status">TX sent: ${tx.hash.slice(
      0,
      10
    )}...</div>`;
    showToast("Transaction sent! Waiting for confirmation...");

    const receipt = await tx.wait();
    if (receipt.status === 1) {
      status.innerHTML = '<div class="status success">✓ Success!</div>';
      showEtherscanLink(tx.hash);
      
      // Special message for USDC IOUs
      if (selectedToken === "USDC") {
        showToast("USDC IOU sent! Receiver can manage at iousdc.eth.limo");
        // Add clickable link in status
        status.innerHTML += `
          <div style="margin-top: 8px; font-size: 12px;">
            Receiver can manage IOUs at 
            <a href="https://iousdc.eth.limo" target="_blank" style="color: var(--accent); text-decoration: underline;">
              iousdc.eth.limo
            </a>
          </div>`;
      } else {
        showToast("Transaction confirmed!");
      }
      
      await fetchAllBalances();
      document.getElementById("toAddress").value = "";
      document.getElementById("amount").value = "";
    } else {
      status.innerHTML = '<div class="status error">Transaction Failed</div>';
      showEtherscanLink(tx.hash);
    }
  } catch (err) {
    // Log error securely without exposing sensitive info
    let errorMsg = "Transaction failed";

    if (err.message.includes("insufficient funds")) {
      errorMsg = "Insufficient funds for gas";
    } else if (err.message.includes("user rejected")) {
      errorMsg = "Transaction rejected";
    } else if (err.message.includes("nonce")) {
      errorMsg = "Nonce error - try again";
    } else if (err.code === "UNKNOWN_ERROR" || err.code === -32603) {
      errorMsg = "Network error - check balance and try again";
    }

    status.innerHTML = `<div class="status error">${errorMsg}</div>`;
  } finally {
    document.getElementById("sendBtn").disabled = false;
  }
}

// IOU Functions for USDC EIP-3009
async function createIOUSlip() {
  const toInput = sanitizeInput(document.getElementById("toAddress").value);
  const amountInput = sanitizeInput(document.getElementById("amount").value);
  const status = document.getElementById("txStatus");

  if (!toInput || !amountInput || !wallet) {
    status.innerHTML = '<div class="status error">Fill all fields</div>';
    return;
  }
  
  // Validate amount for USDC (6 decimals)
  const amountValidation = InputValidator.validateAmount(amountInput, 6);
  if (!amountValidation.valid) {
    status.innerHTML = `<div class="status error">${amountValidation.error}</div>`;
    return;
  }
  
  const amount = amountValidation.formatted;

  try {
    // Validate and resolve address
    let toAddress = toInput;
    let addressValidation;
    
    if (toInput.endsWith(".eth")) {
      // Validate ENS name
      const ensValidation = InputValidator.validateENS(toInput);
      if (!ensValidation.valid) {
        status.innerHTML = `<div class="status error">${ensValidation.error}</div>`;
        return;
      }
      
      toAddress = await resolveENS(toInput);
      if (!toAddress) {
        status.innerHTML = '<div class="status error">ENS name not found</div>';
        return;
      }
      
      addressValidation = InputValidator.validateAddress(toAddress);
    } else {
      addressValidation = InputValidator.validateAddress(toInput);
      if (addressValidation.valid) {
        toAddress = addressValidation.address; // Use checksummed address
      }
    }
    
    if (!addressValidation || !addressValidation.valid) {
      status.innerHTML = `<div class="status error">${addressValidation?.error || 'Invalid address'}</div>`;
      return;
    }

    // Prepare IOU data
    const value = ethers.parseUnits(amount, 6); // USDC has 6 decimals
    const validAfter = 0; // Can be used immediately
    const validDays = 30; // Valid for 30 days by default
    const now = Math.floor(Date.now() / 1000);
    const validBefore = now + (validDays * 86400);
    const nonce = ethers.hexlify(ethers.randomBytes(32));

    // Update modal with preview
    document.getElementById("iouFrom").textContent = `${wallet.address.slice(0, 6)}...${wallet.address.slice(-4)}`;
    document.getElementById("iouTo").textContent = toInput.endsWith(".eth") 
      ? `${toInput} (${toAddress.slice(0, 6)}...${toAddress.slice(-4)})`
      : `${toAddress.slice(0, 6)}...${toAddress.slice(-4)}`;
    document.getElementById("iouAmount").textContent = `${amount} USDC`;
    document.getElementById("iouExpiry").textContent = new Date(validBefore * 1000).toLocaleString();

    // Prepare EIP-712 message
    const message = {
      from: wallet.address,
      to: toAddress,
      value: value.toString(),
      validAfter: String(validAfter),
      validBefore: String(validBefore),
      nonce: nonce
    };

    // Store message for signing
    pendingIouMessage = message;
    pendingIouAmount = amount;

    // Show preview in modal
    const iouData = {
      type: "transfer",
      from: wallet.address,
      to: toAddress,
      value: value.toString(),
      amount: amount,
      validAfter: validAfter,
      validBefore: validBefore,
      nonce: nonce,
      created: new Date().toISOString(),
      chainId: 1
    };

    document.getElementById("iouDataDisplay").value = JSON.stringify(iouData, null, 2);

    // Show modal
    document.getElementById("iouPreviewModal").classList.remove("hidden");

  } catch (err) {
    
    status.innerHTML = '<div class="status error">Failed to create IOU</div>';
  }
}

async function signAndDownloadIOU() {
  try {
    if (!pendingIouMessage || !wallet) {
      throw new Error("No IOU message to sign");
    }

    const status = document.getElementById("txStatus");
    status.innerHTML = '<div class="status">Signing IOU...</div>';

    // Sign EIP-712 message
    const types = { TransferWithAuthorization: EIP3009_TYPES.TransferWithAuthorization };
    const signature = await wallet.signTypedData(USDC_EIP712_DOMAIN, types, pendingIouMessage);
    
    // Extract v, r, s from signature
    const sig = ethers.Signature.from(signature);
    const v = sig.v;
    const r = sig.r;
    const s = sig.s;

    // Create complete IOU slip
    const iouSlip = {
      type: "transfer",
      from: pendingIouMessage.from,
      to: pendingIouMessage.to,
      value: pendingIouMessage.value,
      validAfter: Number(pendingIouMessage.validAfter),
      validBefore: Number(pendingIouMessage.validBefore),
      nonce: pendingIouMessage.nonce,
      v: v,
      r: r,
      s: s,
      amount: pendingIouAmount,
      signature: signature,
      created: new Date().toISOString(),
      chainId: 1
    };

    // Download as JSON file
    const blob = new Blob([JSON.stringify(iouSlip, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `usdc-iou-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);

    // Update display
    document.getElementById("iouDataDisplay").value = JSON.stringify(iouSlip, null, 2);
    
    status.innerHTML = '<div class="status success">IOU signed and downloaded!</div>';
    showToast("IOU created successfully! 📄🪽");

    // Clear form
    document.getElementById("toAddress").value = "";
    document.getElementById("amount").value = "";

    // Clean up
    pendingIouMessage = null;
    pendingIouAmount = null;

  } catch (err) {
    
    let errorMsg = "Failed to sign IOU";
    
    if (err.message.includes("user rejected") || err.message.includes("denied")) {
      errorMsg = "Signature rejected";
    }
    
    document.getElementById("txStatus").innerHTML = `<div class="status error">${errorMsg}</div>`;
  }
}

function setupEventListeners() {
  // Theme toggle
  document.getElementById("themeToggle").addEventListener("click", toggleTheme);

  // Tabs
  document.querySelectorAll(".tab").forEach((tab) => {
    tab.addEventListener("click", () => {
      document
        .querySelectorAll(".tab")
        .forEach((t) => t.classList.remove("active"));
      document
        .querySelectorAll(".tab-content")
        .forEach((c) => c.classList.remove("active"));

      tab.classList.add("active");
      const tabContent = document.getElementById(tab.dataset.tab + "-tab");
      tabContent.classList.add("active");

      // Load transactions when tab is opened
      if (tab.dataset.tab === "txs" && wallet && txHistory.length === 0) {
        fetchTransactionHistory();
      }
    });
  });

  // Transaction history button
  document.getElementById("loadTxBtn").addEventListener("click", () => {
    fetchTransactionHistory();
  });

  // Load more transactions button  
  const loadMoreBtn = document.getElementById("loadMoreTxBtn");
  if (loadMoreBtn) {
    loadMoreBtn.addEventListener("click", async () => {
      try {
        await fetchTransactionHistoryExtended();
      } catch (err) {
        
        showToast("Failed to load transactions");
      }
    });
  }

  // Wallet management
  document
    .getElementById("walletSelector")
    .addEventListener("change", async (e) => {
      const addr = e.target.value;
      if (!addr) return;
      
      // Clean up resources from previous wallet before switching
      cleanupForWalletSwitch();
      
      const list = JSON.parse(localStorage.getItem(LS_WALLETS) || "[]");
      const entry = list.find((w) => w.address === addr);
      // For multi-wallet, ask for password to unlock the specific wallet
      try {
        const pass = await securePasswordPrompt('Unlock Wallet', `Enter password for ${addr.slice(0,6)}...${addr.slice(-4)} to send transaction:`);
        const pk = await decryptPK(
          entry.crypto,
          pass,
          entry.address.toLowerCase()
        );

        // Rewrap legacy keystores that were saved without AAD
        if (!entry.crypto.aad) {
          try {
            const newPayload = await encryptPK(pk, pass, {
              aad: entry.address.toLowerCase(),
            });
            entry.crypto = newPayload;
            const listNow = JSON.parse(
              localStorage.getItem(LS_WALLETS) || "[]"
            ).map((w) =>
              w.address.toLowerCase() === entry.address.toLowerCase()
                ? entry
                : w
            );
            localStorage.setItem(LS_WALLETS, JSON.stringify(listNow));
          } catch (e) {
            
          }
        }

        wallet = new ethers.Wallet(pk, provider);
        await displayWallet();

        localStorage.setItem(LS_LAST, addr);
        showToast("Wallet unlocked!");
      } catch (err) {
        
        showError('Wrong password');
        e.target.value = "";
      }
    });

  document.getElementById("deleteWalletBtn").addEventListener("click", async () => {
    const selector = document.getElementById("walletSelector");
    const address = selector.value;

    if (address && await securePasswordPrompt('Delete Wallet', 'Confirm wallet deletion:')) {
      deleteWallet(address);
      showToast("Wallet deleted");
    }
  });

  document.getElementById("generateBtn").addEventListener("click", async () => {
    try {
      wallet = ethers.Wallet.createRandom().connect(provider);
      saveWallet(wallet.address, wallet.privateKey);
      await displayWallet();
      showToast("Wallet generated!");
    } catch (err) {
      
      showError(err, 'Wallet generation');
    }
  });

  document.getElementById("importBtn").addEventListener("click", () => {
    document.getElementById("importSection").classList.toggle("hidden");
    document.getElementById("privateKeyInput").focus();
  });

  document
    .getElementById("confirmImportBtn")
    .addEventListener("click", async () => {
      const keyInput = sanitizeInput(document.getElementById("privateKeyInput").value);
      if (!keyInput) {
        showToast("Please enter a private key", 3000, 'error');
        return;
      }

      try {
        // Validate private key using InputValidator
        const keyValidation = InputValidator.validatePrivateKey(keyInput);
        if (!keyValidation.valid) {
          showError(new Error(keyValidation.error), 'Private key import');
          return;
        }
        
        // Create wallet with validated key
        wallet = new ethers.Wallet(keyValidation.key, provider);
        
        // Double-check the wallet was created successfully
        if (!wallet.address) {
          throw new Error("Failed to create wallet");
        }
        
        // Check if this address already exists
        const existing = savedWallets.find(w => 
          w.address.toLowerCase() === wallet.address.toLowerCase()
        );
        if (existing) {
          showError(new Error("This wallet is already imported"), 'Private key import');
          return;
        }
        
        await saveWallet(wallet.address, wallet.privateKey);
        await displayWallet();
        
        // Clear sensitive data immediately
        document.getElementById("privateKeyInput").value = "";
        document.getElementById("importSection").classList.add("hidden");
        
        showToast("Wallet imported successfully!");
      } catch (err) {
        // Clear sensitive data on error too
        document.getElementById("privateKeyInput").value = "";
        showError(err, 'Private key import');
      }
    });

  document.getElementById("cancelImportBtn").addEventListener("click", () => {
    document.getElementById("importSection").classList.add("hidden");
    document.getElementById("privateKeyInput").value = "";
  });

  // Copy buttons
  document.querySelectorAll(".copy-btn").forEach((btn) => {
    btn.addEventListener("click", async () => {
      if (!wallet) return;
      const type = btn.dataset.copy;
      if (type === "privateKey") {
        const confirmReveal = await securePasswordPrompt('Security Check', 'Enter password to reveal private key:');
        if (!confirmReveal) return;
      }
      await copyToClipboard(
        type === "address" ? wallet.address : wallet.privateKey,
        type
      );
    });
  });

  // Download key button removed - moved to Settings tab

  document.getElementById("refreshBtn").addEventListener("click", async () => {
    try {
      await fetchAllBalances();
      showToast("Refreshed!");
    } catch (err) {
      
      showToast("Failed to refresh");
    }
  });

  // Add token functionality
  document.getElementById("addTokenBtn").addEventListener("click", () => {
    document.getElementById("addTokenSection").classList.toggle("hidden");
    document.getElementById("newTokenAddress").focus();
  });

  // Live detection of token type
  document.getElementById("newTokenAddress")?.addEventListener("input", async (e) => {
    const addressInput = sanitizeInput(e.target.value);
    const indicator = document.getElementById("tokenTypeIndicator");
    
    if (!addressInput) {
      indicator.classList.add("hidden");
      return;
    }
    
    // Validate address format
    const addressValidation = InputValidator.validateAddress(addressInput);
    if (!addressValidation.valid) {
      indicator.textContent = "✗ " + addressValidation.error;
      indicator.style.color = "var(--error)";
      indicator.classList.remove("hidden");
      return;
    }
    
    try {
      // Validate it's a contract
      const contractValidation = await InputValidator.validateTokenContract(
        addressValidation.address,
        provider
      );
      
      if (!contractValidation.valid) {
        indicator.textContent = "✗ " + contractValidation.error;
        indicator.style.color = "var(--error)";
        indicator.classList.remove("hidden");
        return;
      }
      
      // Check token type
      const isERC6909 = await zWalletContract.isERC6909(addressValidation.address);
      if (isERC6909) {
        indicator.textContent = "✓ ERC6909 detected - Token ID required";
        indicator.style.color = "var(--success)";
        document.getElementById("newTokenId").placeholder = "Token ID (required for ERC6909)";
      } else {
        indicator.textContent = "✓ ERC20 token detected";
        indicator.style.color = "var(--text-secondary)";
        document.getElementById("newTokenId").placeholder = "Token ID (for ERC6909, optional)";
      }
      indicator.classList.remove("hidden");
    } catch (err) {
      indicator.textContent = "✗ Failed to verify token contract";
      indicator.style.color = "var(--error)";
      indicator.classList.remove("hidden");
    }
  });

  document
    .getElementById("confirmAddToken")
    .addEventListener("click", async () => {
      const addressInput = sanitizeInput(document.getElementById("newTokenAddress").value);
      const tokenId = sanitizeInput(document.getElementById("newTokenId").value);
      const symbolOverride = sanitizeInput(document.getElementById("newTokenSymbol").value);

      if (!addressInput) {
        showToast("Please enter a token address", 3000, 'error');
        return;
      }
      
      // Validate address
      const addressValidation = InputValidator.validateAddress(addressInput);
      if (!addressValidation.valid) {
        showError(new Error(addressValidation.error), 'Token addition');
        return;
      }

      try {
        // Validate it's a contract
        const contractValidation = await InputValidator.validateTokenContract(
          addressValidation.address,
          provider
        );
        
        if (!contractValidation.valid) {
          showError(new Error(contractValidation.error), 'Token addition');
          return;
        }
        
        const token = await addCustomToken(addressValidation.address, tokenId);

        // Use override symbol if provided
        if (symbolOverride) {
          // For ERC6909, append ID to symbol
          if (token.isERC6909) {
            token.symbol = `${symbolOverride.toUpperCase()}_${token.id}`;
          } else {
            token.symbol = symbolOverride.toUpperCase();
          }
        }

        // Save the custom token
        saveCustomToken(token);

        // Hide the form
        document.getElementById("addTokenSection").classList.add("hidden");
        document.getElementById("newTokenAddress").value = "";
        document.getElementById("newTokenId").value = "";
        document.getElementById("newTokenSymbol").value = "";
        document.getElementById("tokenTypeIndicator").classList.add("hidden");

        // Refresh balances to include new token
        await fetchAllBalances();
        
        // Refresh swap dropdowns to include new token
        if (typeof initializeTokenDropdowns === 'function') {
          initializeTokenDropdowns();
        }
        
        showToast(`Added ${token.symbol}!`);
      } catch (err) {
        showError(err, 'Token addition');
      }
    });

  // Send functionality
  document.getElementById("maxBtn").addEventListener("click", async () => {
    try {
      const max = await calculateMaxAmount();
      document.getElementById("amount").value = parseFloat(max).toFixed(6);
      await updateEstimatedTotal();
    } catch (err) {
      
      showToast("Failed to calculate max");
    }
  });

  // Debounced ENS resolution handler
  const handleAddressInput = debounce(async (value) => {
    const resolved = getCachedElement("resolvedAddress");
    if (!resolved) return;
    
    if (value.endsWith(".eth")) {
      resolved.textContent = "Resolving...";
      
      try {
        const address = await resolveENS(value);
        // Check if input hasn't changed
        if (getCachedElement("toAddress")?.value.trim() === value) {
          if (address) {
            resolved.textContent = `→ ${formatAddress(address)}`;
            resolved.style.color = "var(--success)";
          } else {
            resolved.textContent = "Not found";
            resolved.style.color = "var(--error)";
          }
        }
      } catch (err) {
        resolved.textContent = "Error resolving";
        resolved.style.color = "var(--error)";
      }
    } else {
      resolved.textContent = "";
    }
    
    updateEstimatedTotal();
  }, CONSTANTS.ENS_RESOLVE_DELAY);
  
  document.getElementById("toAddress").addEventListener("input", (e) => {
    handleAddressInput(e.target.value.trim());
  });

  // Debounced amount input handler
  const handleAmountInput = debounce(updateEstimatedTotal, 300);
  document
    .getElementById("amount")
    .addEventListener("input", handleAmountInput);

  // Gas options
  document.querySelectorAll(".gas-option").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      document
        .querySelectorAll(".gas-option")
        .forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      selectedGasSpeed = btn.dataset.speed;

      const custom = document.getElementById("customGasSection");
      custom.classList.toggle("hidden", selectedGasSpeed !== "custom");

      updateEstimatedTotal();
    });
  });

  document
    .getElementById("customGasPrice")
    .addEventListener("input", async () => {
      if (selectedGasSpeed === "custom") {
        const max = document.getElementById("customGasPrice").value;
        const priority =
          document.getElementById("customPriorityFee").value || "1";

        if (max) {
          gasPrices.custom = {
            maxFeePerGas: ethers.parseUnits(max, "gwei"),
            maxPriorityFeePerGas: ethers.parseUnits(priority, "gwei"),
          };
          await updateEstimatedTotal();
        }
      }
    });

  document.getElementById("sendBtn").addEventListener("click", sendTransaction);
  
  // IOU Mode functionality
  document.getElementById("createIouBtn")?.addEventListener("click", createIOUSlip);
  
  document.getElementById("iouModeToggle")?.addEventListener("change", (e) => {
    const isIouMode = e.target.checked;
    const gasFeeSection = document.getElementById("gasFeeSection");
    const sendBtn = document.getElementById("sendBtn");
    const createIouBtn = document.getElementById("createIouBtn");
    const iouModeInfo = document.getElementById("iouModeInfo");
    
    if (isIouMode) {
      // Switch to IOU mode
      gasFeeSection.style.display = "none";
      sendBtn.classList.add("hidden");
      createIouBtn.classList.remove("hidden");
      iouModeInfo.style.display = "block";
      
      // Update gas display to show "Free!"
      const estimatedTotalEl = document.getElementById("estimatedTotal");
      if (estimatedTotalEl) {
        estimatedTotalEl.innerHTML = '<span style="color: var(--success);">🪽 Free! (Gasless)</span>';
      }
    } else {
      // Switch back to normal mode
      gasFeeSection.style.display = "block";
      sendBtn.classList.remove("hidden");
      createIouBtn.classList.add("hidden");
      iouModeInfo.style.display = "none";
      
      // Restore normal gas display
      updateEstimatedTotal();
    }
  });
  
  // IOU Modal event listeners
  document.getElementById("iouModalClose")?.addEventListener("click", () => {
    document.getElementById("iouPreviewModal").classList.add("hidden");
    // Clean up pending data
    pendingIouMessage = null;
    pendingIouAmount = null;
  });
  
  document.getElementById("confirmIouBtn")?.addEventListener("click", async () => {
    document.getElementById("iouPreviewModal").classList.add("hidden");
    await signAndDownloadIOU();
  });
  
  document.getElementById("cancelIouBtn")?.addEventListener("click", () => {
    document.getElementById("iouPreviewModal").classList.add("hidden");
    // Clean up pending data
    pendingIouMessage = null;
    pendingIouAmount = null;
  });
  
  document.getElementById("toggleIouData")?.addEventListener("click", (e) => {
    const section = document.getElementById("iouDataSection");
    if (section.classList.contains("hidden")) {
      section.classList.remove("hidden");
      e.target.textContent = "Hide";
    } else {
      section.classList.add("hidden");
      e.target.textContent = "Show";
    }
  });
  
  document.getElementById("copyIouData")?.addEventListener("click", async () => {
    const data = document.getElementById("iouDataDisplay").value;
    
    try {
      // Try modern Clipboard API first
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(data);
        showToast("IOU data copied! 📋");
      } else {
        // Fallback for non-secure contexts or older browsers
        const textarea = document.getElementById("iouDataDisplay");
        textarea.focus();
        textarea.select();
        
        // Create a temporary textarea for copying
        const tempTextarea = document.createElement("textarea");
        tempTextarea.value = data;
        tempTextarea.style.position = "fixed";
        tempTextarea.style.left = "-999999px";
        tempTextarea.style.top = "-999999px";
        document.body.appendChild(tempTextarea);
        tempTextarea.focus();
        tempTextarea.select();
        
        try {
          // Try using the Selection API instead of execCommand
          const range = document.createRange();
          range.selectNodeContents(tempTextarea);
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
          
          // Try to write to clipboard using modern API
          const blob = new Blob([data], { type: 'text/plain' });
          const clipboardItem = new ClipboardItem({ 'text/plain': blob });
          await navigator.clipboard.write([clipboardItem]);
          showToast("IOU data copied! 📋");
        } catch (copyErr) {
          // If modern methods fail, show manual copy instruction
          showToast("Please copy manually (Ctrl+C / Cmd+C)", 3000, 'warning');
        } finally {
          document.body.removeChild(tempTextarea);
        }
      }
    } catch (err) {
      showToast("Please select and copy the IOU data manually");
    }
  });
  
  document.getElementById("downloadIou")?.addEventListener("click", () => {
    const data = document.getElementById("iouDataDisplay").value;
    const blob = new Blob([data], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `usdc-iou-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
    showToast("IOU downloaded! 💾");
  });

  // Settings
  document.querySelectorAll(".rpc-item").forEach((item) => {
    item.addEventListener("click", async () => {
      const rpc = item.dataset.rpc;

      if (rpc === "custom") {
        document.getElementById("customRpcSection").classList.toggle("hidden");
      } else {
        currentRpc = rpc;
        localStorage.setItem("rpc_endpoint", rpc);
        await initProvider();

        if (wallet) {
          wallet = wallet.connect(provider);
          await fetchAllBalances();
        }
      }
    });
  });

  document
    .getElementById("saveCustomRpc")
    .addEventListener("click", async () => {
      const urlInput = sanitizeInput(document.getElementById("customRpcUrl").value);
      
      if (!urlInput) {
        showToast("Please enter an RPC URL", 3000, 'error');
        return;
      }

      // Validate RPC URL
      const urlValidation = InputValidator.validateRPCUrl(urlInput);
      if (!urlValidation.valid) {
        showError(new Error(urlValidation.error), 'RPC configuration');
        return;
      }

      try {
        // Test the RPC connection
        const testProvider = new ethers.JsonRpcProvider(urlValidation.url);
        
        // Add timeout for connection test
        const timeoutPromise = new Promise((_, reject) => 
          setManagedTimeout(() => reject(new Error('RPC connection timeout')), 5000)
        );
        
        const blockNumber = await Promise.race([
          testProvider.getBlockNumber(),
          timeoutPromise
        ]);
        
        // Verify it's the correct network (mainnet)
        const network = await testProvider.getNetwork();
        if (network.chainId !== 1n) {
          throw new Error('RPC must be connected to Ethereum mainnet');
        }

        // Save and switch to the new RPC
        localStorage.setItem("custom_rpc", urlValidation.url);
        currentRpc = urlValidation.url;
        localStorage.setItem("rpc_endpoint", urlValidation.url);
        provider = testProvider;
        
        // Reinitialize contracts
        zWalletContract = new ethers.Contract(
          ZWALLET_ADDRESS,
          ZWALLET_ABI,
          provider
        );
        zQuoterContract = new ethers.Contract(
          ZQUOTER_ADDRESS,
          ZQUOTER_ABI,
          provider
        );

        if (wallet) {
          wallet = wallet.connect(provider);
          await fetchAllBalances();
        }

        showToast(`Connected to RPC (Block #${blockNumber})`);
        document.getElementById("customRpcSection").classList.add("hidden");
        loadRpcSettings();
      } catch (err) {
        if (err.message.includes('timeout')) {
          showError(new Error('RPC connection timed out'), 'RPC configuration');
        } else if (err.message.includes('mainnet')) {
          showError(err, 'RPC configuration');
        } else {
          showError(new Error('Failed to connect to RPC'), 'RPC configuration');
        }
      }
    });

  document.getElementById("autoRefresh").addEventListener("change", (e) => {
    if (e.target.checked) {
      if (wallet) {
        autoRefreshInterval = setManagedInterval(() => {
          fetchAllBalances();
          updateGasPrices();
        }, 15000);
      }
    } else {
      clearManagedInterval(autoRefreshInterval);
      autoRefreshInterval = null;
    }
    localStorage.setItem("auto_refresh", e.target.checked);
  });

  // Default wallet toggle handler
  const defaultWalletToggle = document.getElementById("defaultWallet");
  const defaultWalletInfo = document.getElementById("defaultWalletInfo");
  
  if (defaultWalletToggle) {
    // Load saved setting
    chrome.storage.local.get(['zwalletDefault'], (result) => {
      if (result.zwalletDefault) {
        defaultWalletToggle.checked = true;
        defaultWalletInfo.classList.remove('hidden');
      }
    });
    
    defaultWalletToggle.addEventListener("change", (e) => {
      const isDefault = e.target.checked;
      
      // Save setting
      chrome.storage.local.set({ zwalletDefault: isDefault }, () => {
        
        
        // Show/hide info box
        if (isDefault) {
          defaultWalletInfo.classList.remove('hidden');
          showToast('⚡ Default wallet activated! Refresh dApp tabs.');
        } else {
          defaultWalletInfo.classList.add('hidden');
          showToast('Default wallet mode disabled');
        }
        
        // Notify all tabs about the setting change
        chrome.tabs.query({}, (tabs) => {
          tabs.forEach(tab => {
            chrome.tabs.sendMessage(tab.id, {
              type: 'SETTINGS_UPDATED',
              isDefault: isDefault
            }).catch(() => {
              // Ignore errors for tabs without content script
            });
          });
        });
      });
    });
  }

  // Private Key Management in Settings
  document.getElementById("revealKeyBtn")?.addEventListener("click", async () => {
    if (!wallet) {
      showError('Please unlock your wallet first', 'Export');
      return;
    }
    
    const confirmReveal = await securePasswordPrompt('Security Check', 'Enter password to reveal private key:');
    if (!confirmReveal) return;
    
    const keySection = document.getElementById("privateKeySection");
    const keyDisplay = document.getElementById("privateKeyDisplay");
    
    if (keySection && keyDisplay) {
      keyDisplay.textContent = wallet.privateKey;
      keySection.classList.remove("hidden");
      
      // Auto-hide after 60 seconds
      setTimeout(() => {
        keyDisplay.textContent = "••••••••••••••••••••••••••••••••";
        keySection.classList.add("hidden");
      }, 60000);
    }
  });
  
  document.getElementById("hideKeyBtn")?.addEventListener("click", () => {
    const keySection = document.getElementById("privateKeySection");
    const keyDisplay = document.getElementById("privateKeyDisplay");
    
    if (keySection && keyDisplay) {
      keyDisplay.textContent = "••••••••••••••••••••••••••••••••";
      keySection.classList.add("hidden");
    }
  });
  
  document.getElementById("exportKeyBtn")?.addEventListener("click", async () => {
    if (!wallet) {
      showError('Please unlock your wallet first', 'Export');
      return;
    }
    
    try {
      await exportEncryptedKey();
    } catch (err) {
      
      showError(err, 'Key export');
    }
  });

  document.getElementById("exportWallets").addEventListener("click", () => {
    try {
      const data = localStorage.getItem(LS_WALLETS) || "[]";
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `zWallet-backup-${new Date().toISOString().split('T')[0]}.encrypted.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showToast("Encrypted wallets exported!");
    } catch (err) {
      
      showToast("Export failed");
    }
  });

  document.getElementById("clearData").addEventListener("click", () => {
    if (
      confirm(
        "Delete all data, wallets, and custom tokens? This cannot be undone!"
      )
    ) {
      localStorage.clear();
      location.reload();
    }
  });

  // Load auto-refresh setting
  const autoRefresh = localStorage.getItem("auto_refresh") === "true";
  document.getElementById("autoRefresh").checked = autoRefresh;
  
  // Setup swap event listeners
  setupSwapEventListeners();
}

// ============= SWAP FUNCTIONALITY =============
const ZROUTER_ADDRESS = "0x0000000000404FECAf36E6184245475eE1254835";
const ZROUTER_ABI = [
  // swapVZ for ERC6909 tokens (ZAMM and others)
  "function swapVZ(address to, bool exactOut, uint256 feeOrHook, address tokenIn, address tokenOut, uint256 idIn, uint256 idOut, uint256 swapAmount, uint256 amountLimit, uint256 deadline) payable returns (uint256 amountIn, uint256 amountOut)",
  "function swapV2(address to, bool exactOut, address tokenIn, address tokenOut, uint256 swapAmount, uint256 amountLimit, uint256 deadline) payable returns (uint256 amountIn, uint256 amountOut)"
];

// zQuoter ABI for getting best quotes
const ZQUOTER_ABI = [
  "function getQuotes(bool exactOut, address tokenIn, address tokenOut, uint256 swapAmount) view returns ((uint8 source, uint256 feeBps, uint256 amountIn, uint256 amountOut) best, (uint8 source, uint256 feeBps, uint256 amountIn, uint256 amountOut)[] quotes)",
  "function buildBestSwap(address to, bool exactOut, address tokenIn, address tokenOut, uint256 swapAmount, uint256 slippageBps, uint256 deadline) view returns ((uint8 source, uint256 feeBps, uint256 amountIn, uint256 amountOut) best, bytes callData, uint256 amountLimit, uint256 msgValue)"
];

// Note: Multicall3 is for batching view calls only, not state-changing transactions
// Each approval must be a separate transaction

// Helper to calculate pool ID for ERC6909 pairs
function calculatePoolId(id0, id1, token0, token1, swapFee) {
  // Pool key is keccak256(id0, id1, token0, token1, swapFee)
  const abiCoder = new ethers.AbiCoder();
  const encoded = abiCoder.encode(
    ["uint256", "uint256", "address", "address", "uint256"],
    [id0, id1, token0, token1, swapFee]
  );
  return ethers.keccak256(encoded);
}

// Calculate swap output for ERC6909 tokens using constant product formula
async function calculateERC6909SwapOutput(tokenIn, tokenOut, amountIn) {
  try {
    const fromToken = TOKENS[tokenIn];
    const toToken = TOKENS[tokenOut];
    
    // Check if this is an ERC6909 swap
    if (!fromToken?.isERC6909 && !toToken?.isERC6909) {
      return null; // Not an ERC6909 swap
    }
    
    // For now, we only support ETH pairs with ERC6909
    const isETHIn = tokenIn === "ETH";
    const isETHOut = tokenOut === "ETH";
    
    if (!isETHIn && !isETHOut) {
      return null; // Not an ETH pair
    }
    
    // Determine which ZAMM contract to use
    const isZAMM = (fromToken?.id === ZAMM_ID) || (toToken?.id === ZAMM_ID);
    const zammAddress = isZAMM ? ZAMM_0_ADDRESS : ZAMM_1_ADDRESS;
    
    // Create contract instance
    const zammContract = new ethers.Contract(
      zammAddress,
      ZAMM_AMM_ABI,
      provider
    );
    
    // Calculate pool ID - for ERC6909, we need the actual contract address
    const token0 = isETHIn ? ethers.ZeroAddress : (fromToken.isERC6909 ? fromToken.address : fromToken.address);
    const token1 = isETHOut ? ethers.ZeroAddress : (toToken.isERC6909 ? toToken.address : toToken.address);
    const id0 = isETHIn ? 0n : BigInt(fromToken.id || 0);
    const id1 = isETHOut ? 0n : BigInt(toToken.id || 0);
    
    // Sort tokens for pool key - addresses are compared as hex strings
    const shouldSort = token0.toLowerCase() < token1.toLowerCase();
    const sortedToken0 = shouldSort ? token0 : token1;
    const sortedToken1 = shouldSort ? token1 : token0;
    const sortedId0 = shouldSort ? id0 : id1;
    const sortedId1 = shouldSort ? id1 : id0;
    
    // Determine swap direction (zeroForOne means swapping sorted token0 for sorted token1)
    // If ETH is token0 and we're swapping ETH->ZAMM, zeroForOne = true
    // If ETH is token0 and we're swapping ZAMM->ETH, zeroForOne = false
    // If ETH is token1 and we're swapping ETH->ZAMM, zeroForOne = false  
    // If ETH is token1 and we're swapping ZAMM->ETH, zeroForOne = true
    let zeroForOne;
    if (isETHIn) {
      // Swapping ETH for ZAMM
      zeroForOne = shouldSort; // ETH is token0 if sorted
    } else {
      // Swapping ZAMM for ETH
      zeroForOne = !shouldSort; // ZAMM is token0 if not sorted
    }
    
    // Default swap fee is 100 bps (1%)
    const swapFee = 100;
    
    // Calculate pool ID
    const poolId = calculatePoolId(sortedId0, sortedId1, sortedToken0, sortedToken1, swapFee);
    
    // Get pool reserves
    const poolData = await zammContract.pools(poolId);
    const reserve0 = Number(poolData[0]);
    const reserve1 = Number(poolData[1]);
    
    if (reserve0 === 0 || reserve1 === 0) {
      
      return null;
    }
    
    // Calculate output using constant product formula with fee
    // zeroForOne means we're swapping sorted token0 for sorted token1
    const reserveIn = zeroForOne ? reserve0 : reserve1;
    const reserveOut = zeroForOne ? reserve1 : reserve0;
    
    const amountInBigInt = BigInt(amountIn);
    const amountInWithFee = amountInBigInt * BigInt(10000 - swapFee);
    const numerator = amountInWithFee * BigInt(reserveOut);
    const denominator = (BigInt(reserveIn) * 10000n) + amountInWithFee;
    const amountOut = numerator / denominator;
    
    return {
      amountOut,
      poolId,
      zammAddress,
      swapFee,
      reserve0,
      reserve1,
      zeroForOne
    };
  } catch (err) {
    
    return null;
  }
}

// Swap state
let swapFromToken = "ETH";
let swapToToken = "USDC";
let swapSlippage = 0.5; // 0.5% default
let swapMode = "exactIn"; // exactIn or exactOut
let bestSwapRoute = null;
let tokenSelectorTarget = null; // 'from' or 'to'
let swapSimulationTimeout = null; // Debounce timer
let isSimulating = false; // Prevent concurrent simulations

// AMM sources enum from zQuoter contract
const AMM_SOURCES = {
  0: "UNI_V2",
  1: "SUSHI",
  2: "ZAMM"
};

// Standard Uniswap V3 fee tiers
const V3_FEE_TIERS = [500, 3000, 10000]; // 0.05%, 0.3%, 1%

// Uniswap V4 tick spacings
const V4_TICK_SPACINGS = {
  500: 10,    // 0.05% fee
  3000: 60,   // 0.3% fee
  10000: 200  // 1% fee
};

async function setupSwapEventListeners() {
  
  // Function to initialize token dropdowns with logos
  function initializeTokenDropdowns() {
    // Get all available tokens including custom ones
    const swapTokens = Object.keys(TOKENS);
    
    // Populate from dropdown
    const fromDropdown = document.getElementById('swapFromDropdown');
    if (fromDropdown) {
      fromDropdown.innerHTML = swapTokens.map(symbol => {
        const token = TOKENS[symbol];
        const logo = TOKEN_LOGOS[symbol] || generateCoinSVG(symbol);
        return `
          <div class="token-option" data-token="${symbol}" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; cursor: pointer; transition: background 0.2s;">
            <div class="token-option-icon" style="width: 24px; height: 24px;">${logo}</div>
            <span class="token-option-symbol" style="font-weight: 500;">${symbol}</span>
            ${token.isERC6909 ? '<span style="font-size: 10px; color: var(--text-secondary);">(ERC6909)</span>' : ''}
          </div>
        `;
      }).join('');
      
      // Add click handlers
      fromDropdown.querySelectorAll('.token-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          swapFromToken = option.dataset.token;
          updateSwapTokenDisplay('from');
          updateSwapBalances();
          fromDropdown.classList.add('hidden');
          
          // Re-initialize to dropdown based on new from token
          initializeTokenDropdowns();
          
          // Check if current to token is still valid
          const fromToken = TOKENS[swapFromToken];
          const toToken = TOKENS[swapToToken];
          
          if (fromToken?.isERC6909 && swapToToken !== 'ETH') {
            // Force to ETH if from is ERC6909
            swapToToken = 'ETH';
            updateSwapTokenDisplay('to');
          } else if (toToken?.isERC6909 && swapFromToken !== 'ETH') {
            // If to is ERC6909 but from is not ETH, switch to ETH
            swapToToken = 'ETH';
            updateSwapTokenDisplay('to');
          }
          
          if (document.getElementById("swapFromAmount").value) {
            simulateSwap();
          }
        });
      });
    }
    
    // Populate to dropdown - dynamically filter based on from token
    const toDropdown = document.getElementById('swapToDropdown');
    if (toDropdown) {
      // If from token is ERC6909, only show ETH
      // If from token is ETH, show all tokens
      // If from token is ERC20, show ETH and other ERC20s (not ERC6909)
      let toTokens;
      const fromToken = TOKENS[swapFromToken];
      
      if (fromToken?.isERC6909) {
        // ERC6909 can only swap with ETH
        toTokens = ['ETH'];
      } else if (swapFromToken === 'ETH') {
        // ETH can swap with anything
        toTokens = swapTokens;
      } else {
        // ERC20 can swap with ETH and other ERC20s, but not ERC6909
        toTokens = swapTokens.filter(symbol => !TOKENS[symbol].isERC6909);
      }
      
      toDropdown.innerHTML = toTokens.map(symbol => {
        const token = TOKENS[symbol];
        const logo = TOKEN_LOGOS[symbol] || generateCoinSVG(symbol);
        return `
          <div class="token-option" data-token="${symbol}" style="display: flex; align-items: center; gap: 8px; padding: 8px 12px; cursor: pointer; transition: background 0.2s;">
            <div class="token-option-icon" style="width: 24px; height: 24px;">${logo}</div>
            <span class="token-option-symbol" style="font-weight: 500;">${symbol}</span>
            ${token.isERC6909 ? '<span style="font-size: 10px; color: var(--text-secondary);">(ERC6909)</span>' : ''}
          </div>
        `;
      }).join('');
      
      // Add click handlers
      toDropdown.querySelectorAll('.token-option').forEach(option => {
        option.addEventListener('click', (e) => {
          e.stopPropagation();
          swapToToken = option.dataset.token;
          updateSwapTokenDisplay('to');
          updateSwapBalances();
          toDropdown.classList.add('hidden');
          if (document.getElementById("swapFromAmount").value) {
            simulateSwap();
          }
        });
      });
    }
  }
  
  // Initialize token displays and dropdowns
  updateSwapTokenDisplay('from');
  updateSwapTokenDisplay('to');
  initializeTokenDropdowns();
  
  // Setup token selector clicks
  document.getElementById('swapFromTokenSelector')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const dropdown = document.getElementById('swapFromDropdown');
    const otherDropdown = document.getElementById('swapToDropdown');
    
    if (dropdown) {
      dropdown.classList.toggle('hidden');
      otherDropdown?.classList.add('hidden');
    }
  });
  
  document.getElementById('swapToTokenSelector')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const dropdown = document.getElementById('swapToDropdown');
    const otherDropdown = document.getElementById('swapFromDropdown');
    
    if (dropdown) {
      dropdown.classList.toggle('hidden');
      otherDropdown?.classList.add('hidden');
    }
  });
  
  // Hide dropdowns when clicking elsewhere
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.token-selector') && !e.target.closest('.token-dropdown')) {
      document.getElementById('swapFromDropdown')?.classList.add('hidden');
      document.getElementById('swapToDropdown')?.classList.add('hidden');
    }
  });
  
  // Swap direction button
  document.getElementById("swapDirectionBtn")?.addEventListener("click", () => {
    // Check if swap is valid before allowing
    const fromToken = TOKENS[swapFromToken];
    const toToken = TOKENS[swapToToken];
    
    // Don't allow swapping if it would create an invalid pair
    if (fromToken?.isERC6909 && toToken?.isERC6909) {
      showToast("Cannot swap between two ERC6909 tokens");
      return;
    }
    
    // Swap tokens
    const temp = swapFromToken;
    swapFromToken = swapToToken;
    swapToToken = temp;
    
    // Swap amounts
    const fromAmount = document.getElementById("swapFromAmount").value;
    const toAmount = document.getElementById("swapToAmount").value;
    document.getElementById("swapFromAmount").value = toAmount;
    document.getElementById("swapToAmount").value = fromAmount;
    
    // Update displays
    updateSwapTokenDisplay('from');
    updateSwapTokenDisplay('to');
    updateSwapBalances();
    
    // Re-initialize dropdowns with new restrictions
    initializeTokenDropdowns();
    
    if (fromAmount || toAmount) {
      simulateSwap();
    }
  });
  
  // Amount inputs with smart detection and debouncing
  // Debounced swap simulation handler
  const debouncedSimulateSwap = debounce(() => {
    simulateSwap();
  }, CONSTANTS.SWAP_SIMULATION_DELAY);
  
  // Optimized swap from amount handler
  const handleSwapFromInput = (e) => {
    swapMode = "exactIn";
    
    // Sanitize input - only allow numbers and decimal point
    let value = e.target.value.replace(/[^0-9.]/g, '');
    
    // Ensure only one decimal point
    const parts = value.split('.');
    if (parts.length > 2) {
      value = parts[0] + '.' + parts.slice(1).join('');
    }
    
    e.target.value = value;
    
    // Validate against balance
    const inputAmount = parseFloat(e.target.value);
    if (inputAmount && inputAmount > 0) {
      const token = TOKENS[swapFromToken];
      const balanceObj = currentBalances[swapFromToken === "ETH" ? "ETH" : swapFromToken];
      const maxBalance = parseFloat(balanceObj?.formatted || "0");
      
      if (swapFromToken === "ETH") {
        // For ETH, check against actual balance minus gas buffer
        const balanceETH = maxBalance;
        let gasBuffer;
        if (balanceETH < 0.01) {
          gasBuffer = 0.003;
        } else if (balanceETH < 0.05) {
          gasBuffer = 0.005;
        } else {
          gasBuffer = 0.01;
        }
        const effectiveBalance = Math.max(0, maxBalance - gasBuffer);
        
        if (inputAmount > effectiveBalance) {
          e.target.value = effectiveBalance > 0 ? effectiveBalance.toFixed(6) : "0";
          showToast(`Max available: ${effectiveBalance.toFixed(6)} ETH (${gasBuffer} ETH gas reserved)`);
        }
      } else {
        // For tokens, check against token balance
        if (inputAmount > maxBalance) {
          const decimals = token?.decimals || 18;
          const precision = decimals <= 6 ? 6 : (decimals <= 8 ? 8 : 6);
          e.target.value = maxBalance > 0 ? maxBalance.toFixed(precision) : "0";
          showToast(`Max available: ${maxBalance.toFixed(precision)} ${swapFromToken}`);
        }
      }
    }
    
    // Update USD display immediately
    updateSwapUSDValues();
    
    if (e.target.value) {
      debouncedSimulateSwap();
    } else {
      clearSwapQuote();
    }
  };
  
  document.getElementById("swapFromAmount")?.addEventListener("input", handleSwapFromInput);
  
  // Optimized swap to amount handler
  const handleSwapToInput = (e) => {
    swapMode = "exactOut";
    
    // Sanitize input - only allow numbers and decimal point
    let value = e.target.value.replace(/[^0-9.]/g, '');
    
    // Ensure only one decimal point
    const parts = value.split('.');
    if (parts.length > 2) {
      value = parts[0] + '.' + parts.slice(1).join('');
    }
    
    e.target.value = value;
    
    // Update USD display immediately
    updateSwapUSDValues();
    
    if (e.target.value) {
      debouncedSimulateSwap();
    } else {
      clearSwapQuote();
    }
  };
  
  document.getElementById("swapToAmount")?.addEventListener("input", handleSwapToInput);
  
  // Max button
  document.getElementById("swapMaxBtn")?.addEventListener("click", async () => {
    if (!wallet || !provider) {
      showToast("Connect wallet first");
      return;
    }
    
    try {
      let maxAmount;
      const token = TOKENS[swapFromToken];
      
      if (!token || swapFromToken === "ETH") {
        // For ETH, we need to account for gas fees more accurately
        const balanceObj = currentBalances["ETH"];
        if (!balanceObj || !balanceObj.formatted) {
          
          showToast("No ETH balance");
          return;
        }
        
        const balanceETH = parseFloat(balanceObj.formatted);
        
        // Get current gas price to calculate buffer more accurately
        let gasBuffer;
        try {
          const feeData = await provider.getFeeData();
          const gasPrice = feeData.maxFeePerGas || feeData.gasPrice || ethers.parseUnits("30", "gwei");
          
          // Estimate gas for a swap transaction (typically 150k-250k gas)
          const estimatedGasLimit = 250000n; // Conservative estimate
          const estimatedGasCost = gasPrice * estimatedGasLimit;
          const estimatedGasETH = parseFloat(ethers.formatEther(estimatedGasCost));
          
          // Add 20% buffer to gas estimate for safety
          gasBuffer = estimatedGasETH * 1.2;
          
          // Apply minimum gas buffers based on balance
          if (balanceETH < 0.01) {
            // For very small balances, use at least the estimated gas cost
            gasBuffer = Math.max(gasBuffer, estimatedGasETH);
          } else if (balanceETH < 0.05) {
            // For small balances, ensure at least 0.002 ETH buffer
            gasBuffer = Math.max(gasBuffer, 0.002);
          } else if (balanceETH < 0.1) {
            // For medium balances, ensure at least 0.003 ETH buffer
            gasBuffer = Math.max(gasBuffer, 0.003);
          } else {
            // For larger balances, ensure at least 0.005 ETH buffer
            gasBuffer = Math.max(gasBuffer, 0.005);
          }
          
          
        } catch (err) {
          
          // Fallback to conservative buffer if gas estimation fails
          if (balanceETH < 0.01) {
            gasBuffer = 0.002;
          } else if (balanceETH < 0.05) {
            gasBuffer = 0.003;
          } else if (balanceETH < 0.1) {
            gasBuffer = 0.005;
          } else {
            gasBuffer = 0.01;
          }
        }
        
        // Calculate max amount after gas buffer
        maxAmount = Math.max(0, balanceETH - gasBuffer);
        
        // Round down to 6 decimal places to avoid precision issues
        maxAmount = Math.floor(maxAmount * 1000000) / 1000000;
        
        // If the result is too small, set to 0
        if (maxAmount < 0.0001) {
          maxAmount = 0;
          const needed = gasBuffer.toFixed(4);
          showToast(`Need ~${needed} ETH for gas`);
        }
      } else {
        // For tokens, use the formatted balance from currentBalances
        const balanceObj = currentBalances[swapFromToken];
        if (!balanceObj || !balanceObj.formatted) {
          
          showToast(`No ${swapFromToken} balance`);
          return;
        }
        
        maxAmount = parseFloat(balanceObj.formatted);
        
        // Round down to avoid precision issues
        const decimals = token?.decimals || 18;
        if (decimals <= 6) {
          maxAmount = Math.floor(maxAmount * 1000000) / 1000000;
        } else if (decimals <= 8) {
          maxAmount = Math.floor(maxAmount * 100000000) / 100000000;
        } else {
          maxAmount = Math.floor(maxAmount * 1000000) / 1000000;
        }
        
        // Also check if user has ETH for gas
        const ethBalance = currentBalances["ETH"];
        if (!ethBalance || parseFloat(ethBalance.formatted) < 0.001) {
          showToast("Warning: Low ETH for gas");
        }
      }
      
      // Set the value in the input field
      if (maxAmount > 0) {
        const displayDecimals = swapFromToken === "ETH" ? 6 : 
                               (token?.decimals === 6 ? 6 : 
                                token?.decimals === 8 ? 8 : 6);
        document.getElementById("swapFromAmount").value = maxAmount.toFixed(displayDecimals);
        
        // Update USD display
        updateSwapUSDValues();
        
        // Trigger simulation
        swapMode = "exactIn";
        
        // Small delay to ensure UI updates
        setTimeout(() => {
          simulateSwap();
        }, 100);
      } else {
        document.getElementById("swapFromAmount").value = "0";
        updateSwapUSDValues();
      }
    } catch (err) {
      
      showToast("Failed to calculate max");
    }
  });
  
  // Slippage options
  document.querySelectorAll(".slippage-option").forEach((btn) => {
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      document.querySelectorAll(".slippage-option").forEach((b) => b.classList.remove("active"));
      btn.classList.add("active");
      
      const slippage = btn.dataset.slippage;
      if (slippage === "custom") {
        document.getElementById("customSlippageSection")?.classList.remove("hidden");
        // Focus on custom input
        document.getElementById("customSlippage")?.focus();
      } else {
        document.getElementById("customSlippageSection")?.classList.add("hidden");
        swapSlippage = parseFloat(slippage);
        
        // Re-simulate if amounts are present
        if (document.getElementById("swapFromAmount").value || document.getElementById("swapToAmount").value) {
          simulateSwap();
        }
      }
    });
  });
  
  // Custom slippage input
  document.getElementById("customSlippage")?.addEventListener("input", (e) => {
    const value = parseFloat(e.target.value);
    if (!isNaN(value) && value >= 0 && value <= 50) {
      swapSlippage = value;
      if (document.getElementById("swapFromAmount").value || document.getElementById("swapToAmount").value) {
        simulateSwap();
      }
    }
  });
  
  // Swap button
  document.getElementById("swapBtn")?.addEventListener("click", executeSwap);
  
  // Swap confirmation modal
  document.getElementById("swapModalClose")?.addEventListener("click", () => {
    document.getElementById("swapConfirmModal")?.classList.add("hidden");
  });
  
  document.getElementById("cancelSwapBtn")?.addEventListener("click", () => {
    document.getElementById("swapConfirmModal")?.classList.add("hidden");
  });
  
  // Initialize token dropdowns and display
  initializeTokenDropdowns();
  updateSwapTokenDisplay();
  updateSwapBalances();
}

// Update swap token display
function updateSwapTokenDisplay(which = 'both') {
  if (which === 'from' || which === 'both') {
    const fromIcon = document.getElementById("swapFromTokenIcon");
    const fromDisplay = document.getElementById("swapFromTokenDisplay");
    if (fromIcon) fromIcon.innerHTML = TOKEN_LOGOS[swapFromToken] || generateCoinSVG(swapFromToken);
    if (fromDisplay) fromDisplay.textContent = swapFromToken;
  }
  
  if (which === 'to' || which === 'both') {
    const toIcon = document.getElementById("swapToTokenIcon");
    const toDisplay = document.getElementById("swapToTokenDisplay");
    if (toIcon) toIcon.innerHTML = TOKEN_LOGOS[swapToToken] || generateCoinSVG(swapToToken);
    if (toDisplay) toDisplay.textContent = swapToToken;
  }
}

async function updateSwapBalances() {
  const fromBalance = document.getElementById("swapFromBalance");
  const toBalance = document.getElementById("swapToBalance");
  
  if (fromBalance) {
    const balanceObj = currentBalances[swapFromToken];
    const balance = balanceObj ? balanceObj.formatted : "0";
    const numBalance = parseFloat(balance) || 0;
    fromBalance.textContent = numBalance === 0 ? "0.000000" : Math.min(numBalance, 1e10).toFixed(6);
  }
  
  if (toBalance) {
    const balanceObj = currentBalances[swapToToken];
    const balance = balanceObj ? balanceObj.formatted : "0";
    const numBalance = parseFloat(balance) || 0;
    toBalance.textContent = numBalance === 0 ? "0.000000" : Math.min(numBalance, 1e10).toFixed(6);
  }
  
  // Check approval status for non-ETH tokens
  if (swapFromToken !== "ETH" && zWalletContract && wallet) {
    const token = TOKENS[swapFromToken];
    if (token && token.address) {
      try {
        const approvalNeeded = token.isERC6909 
          ? await zWalletContract.checkERC6909RouterIsOperator(wallet.address, token.address)
          : await zWalletContract.checkERC20RouterApproval(wallet.address, token.address, ethers.MaxUint256, true);
        
        // Add visual indicator if approval is needed
        const indicator = document.getElementById("swapFromApprovalIndicator");
        if (indicator) {
          indicator.style.display = (approvalNeeded && approvalNeeded !== "0x") ? "inline" : "none";
          indicator.title = "Approval required for first swap";
        }
      } catch (err) {
        
      }
    }
  }
}

function clearSwapQuote() {
  document.getElementById("swapRoute").textContent = "--";
  document.getElementById("swapMinimum").textContent = "--";
  document.getElementById("swapGasFee").textContent = "--";
  document.getElementById("swapBtn").textContent = "Enter Amount to Swap";
  document.getElementById("swapBtn").disabled = true;
  bestSwapRoute = null;
}

// Helper to update USD values
function updateSwapUSDValues() {
  const fromAmount = document.getElementById("swapFromAmount").value;
  const toAmount = document.getElementById("swapToAmount").value;
  
  const fromUSD = document.getElementById("swapFromUSD");
  const toUSD = document.getElementById("swapToUSD");
  
  if (fromUSD && fromAmount) {
    const price = tokenPrices[swapFromToken]?.usd || 0;
    const usdValue = parseFloat(fromAmount) * price;
    fromUSD.textContent = `$${usdValue.toFixed(2)}`;
  } else if (fromUSD) {
    fromUSD.textContent = "$0.00";
  }
  
  if (toUSD && toAmount) {
    const price = tokenPrices[swapToToken]?.usd || 0;
    const usdValue = parseFloat(toAmount) * price;
    toUSD.textContent = `$${usdValue.toFixed(2)}`;
  } else if (toUSD) {
    toUSD.textContent = "$0.00";
  }
}

async function simulateSwap() {
  if (!wallet || !provider) {
    showToast("Please connect wallet first");
    return;
  }
  
  // Prevent concurrent simulations
  if (isSimulating) {
    
    return;
  }
  
  isSimulating = true;
  
  try {
    const fromToken = TOKENS[swapFromToken];
    const toToken = TOKENS[swapToToken];
    
    // Get amount  
    const amountIn = document.getElementById("swapFromAmount").value;
    if (!amountIn || parseFloat(amountIn) <= 0) {
      clearSwapQuote();
      return;
    }
    
    // Update UI to show loading
    document.getElementById("swapRoute").textContent = "Finding best route...";
    document.getElementById("swapBtn").textContent = "Getting quote...";
    document.getElementById("swapBtn").disabled = true;
    
    // Prepare token addresses (use 0x0 for ETH)
    const tokenInAddress = swapFromToken === "ETH" ? ethers.ZeroAddress : fromToken.address;
    const tokenOutAddress = swapToToken === "ETH" ? ethers.ZeroAddress : toToken.address;
    
    // Convert amount to wei
    const maxDecimals = fromToken?.decimals || 18;
    const truncated = parseFloat(amountIn).toFixed(maxDecimals);
    const swapAmount = ethers.parseUnits(truncated, maxDecimals);
    
    // Check if this is an ERC6909 swap first
    const erc6909Result = await calculateERC6909SwapOutput(swapFromToken, swapToToken, swapAmount);
    
    if (erc6909Result) {
      // This is an ERC6909 swap, use the calculated output
      const outputAmount = erc6909Result.amountOut;
      const outputFormatted = ethers.formatUnits(outputAmount, toToken?.decimals || 18);
      
      // Update UI with ERC6909 quote
      document.getElementById("swapToAmount").value = parseFloat(outputFormatted).toFixed(6);
      document.getElementById("swapRoute").textContent = `ZAMM AMM (${erc6909Result.swapFee / 100}% fee)`;
      document.getElementById("swapBtn").textContent = "Swap";
      document.getElementById("swapBtn").disabled = false;
      
      // Store the route for execution
      bestSwapRoute = {
        isERC6909: true,
        tokenIn: tokenInAddress,
        tokenOut: tokenOutAddress,
        idIn: fromToken?.id || 0,
        idOut: toToken?.id || 0,
        amountIn: swapAmount,
        amountOut: outputAmount,
        slippage: swapSlippage,
        sourceName: "ZAMM AMM",
        poolId: erc6909Result.poolId,
        zammAddress: erc6909Result.zammAddress,
        swapFee: erc6909Result.swapFee,
        zeroForOne: erc6909Result.zeroForOne
      };
      
      updateSwapUSDValues();
      return;
    }
    
    // Not an ERC6909 swap, use zQuoter for regular tokens
    if (!zQuoterContract) {
      
      return;
    }
    
    let quotesResult, bestQuote;
    try {
      // Get quotes from zQuoter (exactOut = false for exactIn mode)
      quotesResult = await zQuoterContract.getQuotes(
        false, // exactOut = false (we're doing exactIn)
        tokenInAddress,
        tokenOutAddress,
        swapAmount
      );
      
      bestQuote = quotesResult.best;
    } catch (quoterError) {
      
      // If quoter fails, show a more specific error
      document.getElementById("swapRoute").textContent = "Quoter unavailable";
      document.getElementById("swapBtn").textContent = "Network error";
      document.getElementById("swapBtn").disabled = true;
      return;
    }
    
    // Check if we got a valid quote
    if (!bestQuote || bestQuote.amountOut === 0n) {
      document.getElementById("swapRoute").textContent = "No route found";
      document.getElementById("swapBtn").textContent = "No liquidity";
      document.getElementById("swapBtn").disabled = true;
      document.getElementById("swapToAmount").value = "";
      updateSwapUSDValues();
      return;
    }
    
    // Format the output amount
    const outputAmount = ethers.formatUnits(bestQuote.amountOut, toToken?.decimals || 18);
    
    document.getElementById("swapToAmount").value = parseFloat(outputAmount).toFixed(6);
    
    // Update USD values
    updateSwapUSDValues();
    
    // Determine the source name
    const sourceNames = ["Uniswap V2", "Sushiswap", "zAMM"];
    const sourceName = sourceNames[bestQuote.source] || `AMM ${bestQuote.source}`;
    
    
    // Calculate minimum received with slippage
    const slippage = swapSlippage;
    const minOutput = parseFloat(outputAmount) * (1 - slippage / 100);
    
    // Estimate gas fee
    const gasPrice = await provider.getFeeData();
    const gasLimit = 200000n; // Estimated gas for swap
    const gasFee = gasPrice.gasPrice * gasLimit;
    const gasFeeETH = ethers.formatEther(gasFee);
    const gasFeeUSD = parseFloat(gasFeeETH) * (tokenPrices["ETH"]?.usd || 0);
    
    // Update UI with quote details
    document.getElementById("swapRoute").textContent = sourceName;
    document.getElementById("swapMinimum").textContent = `${minOutput.toFixed(6)} ${swapToToken}`;
    document.getElementById("swapGasFee").textContent = `$${gasFeeUSD.toFixed(2)}`;
    
    // Store the best quote for execution
    bestSwapRoute = {
      quote: bestQuote,
      tokenIn: tokenInAddress,
      tokenOut: tokenOutAddress,
      amountIn: swapAmount,
      amountOut: bestQuote.amountOut,
      sourceName,
      slippage
    };
    
    // Enable swap button
    document.getElementById("swapBtn").textContent = "Swap";
    document.getElementById("swapBtn").disabled = false;
    
  } catch (err) {
    
    document.getElementById("swapRoute").textContent = "Error";
    document.getElementById("swapBtn").textContent = "Try again";
    document.getElementById("swapBtn").disabled = false;
  } finally {
    isSimulating = false;
  }
}

async function executeSwap() {
  if (!wallet) {
    showToast("Please connect wallet first");
    return;
  }
  
  if (!bestSwapRoute) {
    showToast("Please enter amount to get quote first");
    return;
  }
  
  try {
    // Check if approval is needed for non-ETH tokens
    if (swapFromToken !== "ETH") {
      const fromToken = TOKENS[swapFromToken];
      const needsApproval = await checkAndRequestApproval(fromToken, bestSwapRoute.amountIn);
      if (!needsApproval) return;
    }
    
    let callData, msgValue;
    const deadline = Math.floor(Date.now() / 1000) + 3600; // 1 hour deadline
    
    if (bestSwapRoute.isERC6909) {
      // Handle ERC6909 swap using swapVZ
      const fromToken = TOKENS[swapFromToken];
      const toToken = TOKENS[swapToToken];
      
      // For ZAMM, use max deadline to use the old ZAMM_0 contract
      const vzDeadline = fromToken?.id === ZAMM_ID || toToken?.id === ZAMM_ID 
        ? ethers.MaxUint256 
        : deadline;
      
      // Calculate minimum output with slippage
      const minOutput = bestSwapRoute.amountOut * BigInt(Math.floor((100 - swapSlippage) * 100)) / 10000n;
      
      // Create zRouter contract instance
      const zRouter = new ethers.Contract(ZROUTER_ADDRESS, ZROUTER_ABI, wallet);
      
      // Build swapVZ calldata - need actual token addresses for ERC6909
      const tokenInAddr = swapFromToken === "ETH" ? ethers.ZeroAddress : fromToken.address;
      const tokenOutAddr = swapToToken === "ETH" ? ethers.ZeroAddress : toToken.address;
      const idIn = swapFromToken === "ETH" ? 0n : BigInt(fromToken.id || 0);
      const idOut = swapToToken === "ETH" ? 0n : BigInt(toToken.id || 0);
      
      const swapVZCall = zRouter.interface.encodeFunctionData("swapVZ", [
        wallet.address, // to
        false, // exactOut = false
        bestSwapRoute.swapFee, // feeOrHook (100 bps = 1%)
        tokenInAddr, // tokenIn
        tokenOutAddr, // tokenOut
        idIn, // idIn
        idOut, // idOut
        bestSwapRoute.amountIn, // swapAmount
        minOutput, // amountLimit
        vzDeadline // deadline
      ]);
      
      callData = swapVZCall;
      msgValue = swapFromToken === "ETH" ? bestSwapRoute.amountIn : 0n;
      
    } else {
      // Use zQuoter for regular token swaps
      if (!zQuoterContract) {
        throw new Error("zQuoter contract not initialized");
      }
      
      const slippageBps = Math.floor(bestSwapRoute.slippage * 100); // Convert % to basis points
      
      let swapData;
      try {
        swapData = await zQuoterContract.buildBestSwap(
          wallet.address,
          false, // exactOut = false
          bestSwapRoute.tokenIn,
          bestSwapRoute.tokenOut,
          bestSwapRoute.amountIn,
          slippageBps,
          deadline
        );
      } catch (err) {
        
        showToast("Failed to prepare swap");
        return;
      }
      
      // Extract the calldata and value
      callData = swapData.callData;
      msgValue = swapData.msgValue;
    }
    
    // Show confirmation modal
    const modal = document.getElementById("swapConfirmModal");
    const fromToken = TOKENS[swapFromToken];
    const toToken = TOKENS[swapToToken];
    
    // Populate confirmation details
    const inputFormatted = ethers.formatUnits(bestSwapRoute.amountIn, fromToken?.decimals || 18);
    const outputFormatted = ethers.formatUnits(bestSwapRoute.amountOut, toToken?.decimals || 18);
    
    document.getElementById("confirmSwapFrom").textContent = `${parseFloat(inputFormatted).toFixed(6)} ${swapFromToken}`;
    document.getElementById("confirmSwapTo").textContent = `${parseFloat(outputFormatted).toFixed(6)} ${swapToToken}`;
    document.getElementById("confirmSwapRoute").textContent = bestSwapRoute.sourceName || "Best Route";
    document.getElementById("confirmSwapSlippage").textContent = `${swapSlippage}%`;
    
    const minOutput = bestSwapRoute.amountOut * BigInt(Math.floor((100 - swapSlippage) * 100)) / 10000n;
    const minFormatted = ethers.formatUnits(minOutput, toToken?.decimals || 18);
    document.getElementById("confirmSwapMinimum").textContent = `${parseFloat(minFormatted).toFixed(6)} ${swapToToken}`;
    
    const gasPrice = (await provider.getFeeData()).maxFeePerGas || ethers.parseUnits("30", "gwei");
    const gasLimit = 200000n; // Estimated
    const gasCost = gasLimit * gasPrice;
    const gasCostEth = ethers.formatEther(gasCost);
    document.getElementById("confirmSwapGas").textContent = `${parseFloat(gasCostEth).toFixed(5)} ETH`;
    
    const totalCostEth = swapFromToken === "ETH" 
      ? parseFloat(inputFormatted) + parseFloat(gasCostEth)
      : parseFloat(gasCostEth);
    document.getElementById("confirmSwapTotal").textContent = `${totalCostEth.toFixed(6)} ETH`;
    
    // Setup calldata display
    const calldataDisplay = document.getElementById("swapCalldataDisplay");
    if (calldataDisplay) calldataDisplay.value = callData;
    
    // Setup Swiss Knife decoder link
    const swissKnifeLink = document.getElementById("swapSwissKnifeLink");
    if (swissKnifeLink) {
      if (callData && callData !== '0x' && callData.length > 2) {
        swissKnifeLink.href = `https://calldata.swiss-knife.xyz/decoder?calldata=${callData}`;
        swissKnifeLink.style.display = 'inline-block';
        swissKnifeLink.onclick = (e) => {
          e.preventDefault();
          const url = `https://openchain.xyz/trace/ethereum?calldata=${callData}`;
          if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
            chrome.runtime.sendMessage({ action: 'open_external', url });
          } else {
            window.open(url, '_blank', 'noopener,noreferrer');
          }
        };
      } else {
        swissKnifeLink.style.display = 'none';
      }
    }
    
    const toggleBtn = document.getElementById("toggleSwapCalldata");
    const calldataSection = document.getElementById("swapCalldataSection");
    if (toggleBtn) {
      toggleBtn.onclick = () => {
        if (calldataSection.classList.contains("hidden")) {
          calldataSection.classList.remove("hidden");
          toggleBtn.textContent = "Hide";
        } else {
          calldataSection.classList.add("hidden");
          toggleBtn.textContent = "Show";
        }
      };
    }
    
    modal.classList.remove("hidden");
    
    // Wait for user confirmation
    const userConfirmed = await new Promise(resolve => {
      const confirmBtn = document.getElementById("confirmSwapBtn");
      const cancelBtn = document.getElementById("cancelSwapBtn");
      
      const handleConfirm = () => {
        cleanup();
        resolve(true);
      };
      
      const handleCancel = () => {
        cleanup();
        resolve(false);
      };
      
      const cleanup = () => {
        confirmBtn.removeEventListener("click", handleConfirm);
        cancelBtn.removeEventListener("click", handleCancel);
        modal.classList.add("hidden");
      };
      
      confirmBtn.addEventListener("click", handleConfirm);
      cancelBtn.addEventListener("click", handleCancel);
    });
    
    if (!userConfirmed) {
      
      return;
    }
    
    // Execute the swap
    document.getElementById("swapStatus").innerHTML = '<div style="color: var(--warning)">Sending transaction...</div>';
    
    // Get current nonce for replay protection
    const nonce = await wallet.getNonce();
    
    const tx = await wallet.sendTransaction({
      to: ZROUTER_ADDRESS,
      data: callData,
      value: msgValue,
      nonce: nonce
    });
    
    document.getElementById("swapStatus").innerHTML = `<div style="color: var(--info)">Transaction sent: ${tx.hash.slice(0, 10)}...</div>`;
    
    // Wait for confirmation
    const receipt = await tx.wait();
    
    if (receipt.status === 1) {
      // Show success message with multiple explorer links
      const swapStatus = document.getElementById("swapStatus");
      swapStatus.innerHTML = '<div style="color: var(--success)">✓ Swap successful!</div>';
      
      // Create container for explorer links
      const linksContainer = document.createElement("div");
      linksContainer.style.cssText = "margin-top: 8px; display: flex; gap: 12px; flex-wrap: wrap;";
      
      // Add Etherscan link
      const etherscanLink = document.createElement("a");
      etherscanLink.href = "#";
      etherscanLink.textContent = "Etherscan →";
      etherscanLink.style.cssText = "color: var(--accent); text-decoration: underline; font-size: 12px;";
      etherscanLink.onclick = (e) => {
        e.preventDefault();
        const url = `https://etherscan.io/tx/${tx.hash}`;
        if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage({ action: 'open_external', url });
        } else {
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      };
      
      // Add decoder link for swap analysis
      const decoderLink = document.createElement("a");
      decoderLink.href = "#";
      decoderLink.textContent = "Decode Swap →";
      decoderLink.style.cssText = "color: var(--accent); text-decoration: underline; font-size: 12px;";
      decoderLink.onclick = (e) => {
        e.preventDefault();
        const url = `https://openchain.xyz/trace/ethereum/${tx.hash}`;
        if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage({ action: 'open_external', url });
        } else {
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      };
      
      // Add Tenderly for detailed swap debugging
      const tenderlyLink = document.createElement("a");
      tenderlyLink.href = "#";
      tenderlyLink.textContent = "Debug →";
      tenderlyLink.style.cssText = "color: var(--accent); text-decoration: underline; font-size: 12px;";
      tenderlyLink.onclick = (e) => {
        e.preventDefault();
        const url = `https://dashboard.tenderly.co/tx/mainnet/${tx.hash}`;
        if (chrome && chrome.runtime && chrome.runtime.sendMessage) {
          chrome.runtime.sendMessage({ action: 'open_external', url });
        } else {
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      };
      
      linksContainer.appendChild(etherscanLink);
      linksContainer.appendChild(decoderLink);
      linksContainer.appendChild(tenderlyLink);
      swapStatus.appendChild(linksContainer);
      
      showToast("Swap successful!");
      
      // Clear inputs and refresh balances
      document.getElementById("swapFromAmount").value = "";
      document.getElementById("swapToAmount").value = "";
      clearSwapQuote();
      await fetchAllBalances();
    } else {
      throw new Error("Transaction failed");
    }
    
  } catch (err) {
    
    document.getElementById("swapStatus").innerHTML = `<div style="color: var(--error)">✗ ${err.message || "Swap failed"}</div>`;
    showToast(`Swap failed: ${err.message || "Unknown error"}`);
  }
}
async function checkAndRequestApproval(token, amount) {
  if (!token || !token.address) return true;
  
  try {
    // Handle ERC6909 tokens (like ZAMM)
    if (token.isERC6909) {
      // Use zWallet contract helper to check if operator approval is needed
      if (!zWalletContract) {
        throw new Error("zWallet contract not initialized");
      }
      
      // Get the approval payload if needed (returns empty bytes if already approved)
      // This checks if zRouter is an operator for the user on the ERC6909 token contract
      const approvalPayload = await zWalletContract.checkERC6909RouterIsOperator(
        wallet.address,
        token.address
      );
      
      if (!approvalPayload || approvalPayload === "0x") {
        return true; // Already approved as operator
      }
      
      // Show approval modal with details
      const approvalConfirmed = await showApprovalModal(token, true);
      
      if (!approvalConfirmed) return false;
      
      document.getElementById("swapStatus").innerHTML = '<div class="status">Setting operator approval...</div>';
      
      // Execute the approval using the generated calldata
      const approveTx = await wallet.sendTransaction({
        to: token.address,
        data: approvalPayload,
        gasLimit: await provider.estimateGas({
          from: wallet.address,
          to: token.address,
          data: approvalPayload
        })
      });
      
      document.getElementById("swapStatus").innerHTML = `<div class="status">Approving... ${approveTx.hash.slice(0, 10)}...</div>`;
      await approveTx.wait();
      
      showToast(`${token.symbol} operator approval granted!`);
      return true;
      
    } else {
      // Standard ERC20 approval flow
      if (!zWalletContract) {
        throw new Error("zWallet contract not initialized");
      }
      
      // Use zWallet helper to check if approval is needed and get calldata
      // The 'true' parameter means approve max amount to avoid future approvals
      const approvalPayload = await zWalletContract.checkERC20RouterApproval(
        wallet.address,
        token.address,
        amount,
        true // Use max approval
      );
      
      if (!approvalPayload || approvalPayload === "0x") {
        return true; // Already approved
      }
      
      // Show approval modal with details
      const approvalConfirmed = await showApprovalModal(token, false);
      
      if (!approvalConfirmed) return false;
      
      document.getElementById("swapStatus").innerHTML = '<div class="status">Approving token...</div>';
      
      // Execute the approval using the generated calldata
      const approveTx = await wallet.sendTransaction({
        to: token.address,
        data: approvalPayload,
        gasLimit: await provider.estimateGas({
          from: wallet.address,
          to: token.address,
          data: approvalPayload
        })
      });
      
      document.getElementById("swapStatus").innerHTML = `<div class="status">Approving... ${approveTx.hash.slice(0, 10)}...</div>`;
      await approveTx.wait();
      
      showToast(`${token.symbol} approved for swapping!`);
      return true;
    }
    
  } catch (err) {
    
    document.getElementById("swapStatus").innerHTML = '<div class="status error">Approval failed</div>';
    showToast("Approval failed");
    return false;
  }
}

// Batch check approval status for multiple tokens
async function batchCheckApprovals(tokens, amounts = []) {
  if (!zWalletContract || !wallet) return {};
  
  const approvalStatus = {};
  
  try {
    // Process tokens in parallel for efficiency
    const promises = tokens.map(async (token, index) => {
      const amount = amounts[index] || ethers.MaxUint256;
      
      if (token.isERC6909) {
        // Check ERC6909 operator status
        const payload = await zWalletContract.checkERC6909RouterIsOperator(
          wallet.address,
          token.address
        );
        approvalStatus[token.address] = {
          needsApproval: payload && payload !== "0x",
          type: 'operator',
          payload
        };
      } else {
        // Check ERC20 allowance
        const payload = await zWalletContract.checkERC20RouterApproval(
          wallet.address,
          token.address,
          amount,
          true // Max approval
        );
        approvalStatus[token.address] = {
          needsApproval: payload && payload !== "0x",
          type: 'allowance',
          payload
        };
      }
    });
    
    await Promise.all(promises);
  } catch (err) {
    
  }
  
  return approvalStatus;
}

// Pre-generate approval calldata for multiple tokens
async function prepareApprovalCalldata(token, amount = ethers.MaxUint256) {
  if (!zWalletContract) return null;
  
  try {
    if (token.isERC6909) {
      return await zWalletContract.getERC6909SetOperator(ZROUTER_ADDRESS, true);
    } else {
      return await zWalletContract.getERC20Approve(ZROUTER_ADDRESS, amount);
    }
  } catch (err) {
    
    return null;
  }
}

// Execute multiple approvals sequentially (each requires separate transaction)
async function executeApprovalSequence(approvalData) {
  if (!wallet || !provider) return false;
  
  const results = [];
  
  for (const approval of approvalData) {
    try {
      const tx = await wallet.sendTransaction({
        to: approval.tokenAddress,
        data: approval.calldata,
        gasLimit: await provider.estimateGas({
          from: wallet.address,
          to: approval.tokenAddress,
          data: approval.calldata
        })
      });
      
      showToast(`Approving ${approval.token}...`);
      await tx.wait();
      results.push({ token: approval.token, success: true });
    } catch (err) {
      
      results.push({ token: approval.token, success: false, error: err.message });
    }
  }
  
  const successCount = results.filter(r => r.success).length;
  if (successCount === approvalData.length) {
    showToast("All token approvals completed!");
  } else if (successCount > 0) {
    showToast(`${successCount}/${approvalData.length} approvals completed`);
  } else {
    showToast("Approvals failed");
  }
  
  return results;
}

// Helper to check and prepare all necessary approvals
async function prepareAllNecessaryApprovals() {
  if (!zWalletContract || !wallet) return [];
  
  const approvals = [];
  const tokensToCheck = Object.values(TOKENS).filter(t => t.address && t.symbol !== "ETH");
  
  for (const token of tokensToCheck) {
    try {
      const payload = token.isERC6909
        ? await zWalletContract.checkERC6909RouterIsOperator(wallet.address, token.address)
        : await zWalletContract.checkERC20RouterApproval(wallet.address, token.address, ethers.MaxUint256, true);
      
      if (payload && payload !== "0x") {
        approvals.push({
          token: token.symbol,
          tokenAddress: token.address,
          calldata: payload,
          type: token.isERC6909 ? 'operator' : 'allowance'
        });
      }
    } catch (err) {
      
    }
  }
  
  return approvals;
}

async function showApprovalModal(token, isERC6909) {
  return new Promise((resolve) => {
    // Create a simple approval modal
    const modalHtml = `
      <div id="approvalModal" class="modal">
        <div class="modal-content">
          <div class="modal-header">
            <h3>Approval Required</h3>
            <button class="modal-close" id="approvalModalClose">×</button>
          </div>
          <div class="modal-body">
            <div class="warning" style="margin-bottom: 16px;">
              ⚠️ First-time swap requires approval
            </div>
            <div class="confirm-row">
              <span class="confirm-label">Token:</span>
              <span class="confirm-value">${token.symbol}</span>
            </div>
            <div class="confirm-row">
              <span class="confirm-label">Contract:</span>
              <span class="confirm-value mono" style="font-size: 10px;">${token.address.slice(0, 6)}...${token.address.slice(-4)}</span>
            </div>
            <div class="confirm-row">
              <span class="confirm-label">Approval Type:</span>
              <span class="confirm-value">${isERC6909 ? 'ERC6909 Operator' : 'ERC20 Allowance'}</span>
            </div>
            <div class="confirm-row">
              <span class="confirm-label">Spender:</span>
              <span class="confirm-value mono" style="font-size: 10px;">zRouter: ${ZROUTER_ADDRESS.slice(0, 6)}...${ZROUTER_ADDRESS.slice(-4)}</span>
            </div>
            <div style="margin-top: 12px; padding: 12px; background: var(--info-bg); border: 1px solid var(--border); font-size: 11px;">
              ${isERC6909 
                ? 'This will grant zRouter permission to transfer your ERC6909 tokens (like ZAMM) for swapping.'
                : 'This will grant zRouter permission to spend your tokens for swapping. This is a one-time approval.'}
            </div>
          </div>
          <div class="modal-footer">
            <button id="confirmApproval" class="btn-confirm">Approve</button>
            <button id="cancelApproval" class="btn-cancel">Cancel</button>
          </div>
        </div>
      </div>
    `;
    
    // Add modal to page
    const modalDiv = document.createElement('div');
    modalDiv.innerHTML = modalHtml;
    document.body.appendChild(modalDiv);
    
    const confirmBtn = document.getElementById('confirmApproval');
    const cancelBtn = document.getElementById('cancelApproval');
    const closeBtn = document.getElementById('approvalModalClose');
    
    const cleanup = () => {
      document.body.removeChild(modalDiv);
      resolve(false);
    };
    
    const handleConfirm = () => {
      document.body.removeChild(modalDiv);
      resolve(true);
    };
    
    confirmBtn.addEventListener('click', handleConfirm);
    cancelBtn.addEventListener('click', cleanup);
    closeBtn.addEventListener('click', cleanup);
  });
}

// Initialize app with proper error handling
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    initPasswordModal();
    init().catch(() => {
      // Show user-friendly error
      const errorDiv = document.createElement('div');
      errorDiv.className = 'status error';
      errorDiv.textContent = 'Failed to initialize wallet. Please reload.';
      document.body.appendChild(errorDiv);
    });
  });
} else {
  init().catch(() => {
    // Error already handled in init function
  });
}
